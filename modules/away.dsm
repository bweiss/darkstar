/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * AWAY.DSM - Away module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 10/12/01 (bmw)
 *
 * This script uses serial number 421 for all ON hooks.
 */

queue cleanup.away
{
	for alias in (away back readlog remlog)
	{
		^alias -$alias
	}

	^on #305 421 -"*"
	^on #306 421 -"*"
	^on #msg 421 -"*"
	^on #notice 421 -"*"
	^on #input 421 -"*"
	^on #timer 421 -"*"
	^on #timer 421 -"12:00"

	@ delarray(sent_away)
}


/*
 * Timestamp for last user input. Needed for auto-away.
 */
@ AWAY.LAST_INPUT = time()


/*
 * /AWAY [-l] [reason]
 * Set or unset yourself away. This just changes the default behavior of
 * //AWAY from being local to global. If the "-l" option is not specified,
 * the "-a" option will be passed to //AWAY.
 */
alias away (args)
{
	if (word(0 $args) == [-l])
	{
		//away $restw(1 $args)
	}{
		//away -a $args
	}
}

/*
 * /BACK [-l]
 * Set yourself back. This is the same as executing //AWAY with no arguments.
 * If the "-l" option is not specified, the "-a" option (global away) will be
 * passed to //AWAY.
 */
alias back (option, void)
{
	if (option == [-l])
	{
		//away
	}{
		//away -a
	}
}

/*
 * /READLOG
 * Displays your away log to the current window in a way similar to the more
 * pager.
 *
 * This was taken from archon's 'more' script distributed with EPIC
 * http://www.epicsol.org/
 */
alias readlog (void)
{
	if (fexist($CONFIG.AWAY_LOGFILE) == 1)
	{
		less $CONFIG.AWAY_LOGFILE
	}{
		xecho -b Logfile [$CONFIG.AWAY_LOGFILE] does not exist.
	}
}

/*
 * /REMLOG
 * Removes your away log.
 */
alias remlog (void)
{
	^assign -AWAY.NEWMSGS

	if (fexist($CONFIG.AWAY_LOGFILE))
	{
		@ unlink($CONFIG.AWAY_LOGFILE)
		xecho -b Removed logfile [$CONFIG.AWAY_LOGFILE]
	}{
		xecho -b Logfile [$CONFIG.AWAY_LOGFILE] does not exist.
	}
	
	if (A && CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [MsgLog Started $strftime(%c)])
		@ close($fd)
	}
}


/*
 * You have set yourself away.
 */
on #-306 421 "*"
{
	if (CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [MsgLog Started $strftime(%c)])
		@ close($fd)
	}

	if (CONFIG[PUBLIC_AWAY])
	{
		if (CONFIG[PUBLIC_AWAY_CHANNELS])
		{
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS)
			{
				if (match($chan $mychannels()))
				{
					describe $chan is away: $A [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
				}
			}
		}{
			for chan in ($mychannels())
			{
				describe $chan is away: $A [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
			}
		}
	}

	^on #^msg 421 "*"
	{
		if (A)
		{
			@ away.process_incoming(MSG $*)
		}
	}

	^on #^notice 421 "*"
	{
		if (A)
		{
			@ away.process_incoming(NOTICE $*)
		}
	}

	^assign AWAY.TIME $time()
}

/*
 * You have unset away.
 */
on #-305 421 "*"
{
	if (CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [MsgLog Stopped $strftime(%c)])
		@ close($fd)
	}

	if (CONFIG[PUBLIC_AWAY])
	{
		if (CONFIG[PUBLIC_AWAY_CHANNELS])
		{
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS)
			{
				if (match($chan $mychannels()))
				{
					describe $chan is back [Gone since: $strftime($AWAY.TIME %c)]
				}
			}
		}{
			for chan in ($mychannels())
			{
				describe $chan is back [Gone since: $strftime($AWAY.TIME %c)]
			}
		}
	}

	^on #msg 421 -"*"
	^on #notice 421 -"*"

	@ delarray(sent_away)
	^assign -AWAY.TIME

	if (AWAY[NEWMSGS])
	{
		xecho -b You have $AWAY.NEWMSGS new message${AWAY[NEWMSGS] > 1 ? [s] : []}.
	}
		
	@ away.prompt_readlog()
}

/*
 * Update TS for last input and check for auto-unset-away.
 */
on #^input 421 "*"
{
	@ AWAY.LAST_INPUT = time()
	
	if (A && CONFIG[AUTO_UNSET_AWAY])
	{
		back
	}
}

/*
 * Set ourselves away if auto-away is enabled and we have been idle longer
 * than $CONFIG.AUTO_AWAY_TIME.
 */
on #^timer 421 "*"
{
	if (!A && CONFIG[AUTO_AWAY] && CONFIG[AUTO_AWAY_TIME] > 0)
	{
		@ :diff = time() - CONFIG[AUTO_AWAY_TIME]
		@ :minutes = CONFIG[AUTO_AWAY_TIME] / 60

		if (diff >= AWAY[LAST_INPUT])
		{
			away Auto-away after $minutes minute${minutes > 1 ? [s] : []}.
		}
	}
}

/*
 * Timestamp our logfile at noon if we are away. This is important because
 * logged messages do not contain the date.
 */
on #^timer 421 "12:00"
{
	if (A && CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [TimeStamp $strftime(%c)])
		@ close($fd)
	}
}

/*
 * This handles the actual writing of messages to your logfile as well
 * as notifying users that you are away.
 */
alias away.process_incoming (type, nick, msg)
{
	if (CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [$strftime($time() %X)] $type [$nick!$userhost()] $msg)
		@ close($fd)

		@ AWAY.NEWMSGS++
	}

	if (CONFIG[SEND_AWAY_NOTICE] && type == [MSG] && finditem(sent_away $nick) < 0)
	{
		@ setitem(sent_away $numitems(sent_away) $nick)
		notice $nick I am currently away. \($A\) [Gone since: $strftime($AWAY.TIME %c)] [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
	}

	return
}

alias away.prompt_readlog (void)
{
	if (AWAY[NEWMSGS])
	{
		input "$INPUT_PROMPT\Would you like to read your msgs now? (y/N) "
		{
			switch ($tolower($mid(0 1 $0)))
			{
				(y) { readlog }
				(*) { # nada }
			}
		}
	}

	return
}


/* bmw '01 */