/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * AWAY.DSM - Away module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 10/21/01 (bmw)
 *
 * This script uses serial number 421 for all ON hooks.
 */

queue cleanup.away
{
	for alias in (readlog remlog)
	{
		^alias -$alias
	}

	^on #305 421 -"*"
	^on #306 421 -"*"
	^on #msg 421 -"*"
	^on #notice 421 -"*"
	^on #input 421 -"*"
	^on #timer 421 -"*"
	^on #timer 421 -"12:00"

	@ delarray(sent_away)
}


/*
 * Timestamp for last user input. Needed for auto-away.
 */
@ AWAY.LAST_INPUT = time()


/*
 * /READLOG
 * Displays your away log to the current window using /LESS.
 */
alias readlog (file default "$CONFIG.AWAY_LOGFILE", void)
{
	^assign -AWAY.NEWMSGS

	if (fexist($file) == 1)
	{
		less $file
	}{
		xecho -b Logfile [$file] does not exist.
	}
}

/*
 * /REMLOG [filename]
 * Removes your away log.
 */
alias remlog (file default "$CONFIG.AWAY_LOGFILE", void)
{
	^assign -AWAY.NEWMSGS

	if (fexist($file))
	{
		@ unlink($file)
		xecho -b Removed logfile [$file]
	}{
		xecho -b Logfile [$file] does not exist.
	}	
}


/*
 * You have set yourself away.
 */
on #-306 421 "*"
{
	if (CONFIG[PUBLIC_AWAY])
	{
		if (CONFIG[PUBLIC_AWAY_CHANNELS])
		{
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS)
			{
				if (match($chan $mychannels()))
				{
					describe $chan is away: $A [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
				}
			}
		}{
			for chan in ($mychannels())
			{
				describe $chan is away: $A [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
			}
		}
	}

	^on #^msg 421 "*"
	{
		if (A)
		{
			@ away.process_incoming(MSG $*)
		}
	}

	^on #^notice 421 "*"
	{
		if (A)
		{
			@ away.process_incoming(NOTICE $*)
		}
	}

	^assign AWAY.TIME $time()
}

/*
 * You have unset away.
 */
on #-305 421 "*"
{
	if (CONFIG[PUBLIC_AWAY])
	{
		if (CONFIG[PUBLIC_AWAY_CHANNELS])
		{
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS)
			{
				if (match($chan $mychannels()))
				{
					describe $chan is back [Gone since: $strftime($AWAY.TIME %c)]
				}
			}
		}{
			for chan in ($mychannels())
			{
				describe $chan is back [Gone since: $strftime($AWAY.TIME %c)]
			}
		}
	}

	^on #msg 421 -"*"
	^on #notice 421 -"*"

	@ delarray(sent_away)
	^assign -AWAY.TIME

	if (AWAY[NEWMSGS])
	{
		xecho -b You have $AWAY.NEWMSGS new message${AWAY[NEWMSGS] > 1 ? [s] : []}.
	}
}

/*
 * Update TS for last input and check for auto-unset-away.
 */
on #^input 421 "*"
{
	@ AWAY.LAST_INPUT = time()
	
	if (A && CONFIG[AUTO_UNSET_AWAY])
	{
		//away -a
	}
}

/*
 * Set ourselves away if auto-away is enabled and we have been idle longer
 * than $CONFIG.AUTO_AWAY_TIME.
 */
on #^timer 421 "*"
{
	if (!A && CONFIG[AUTO_AWAY] && CONFIG[AUTO_AWAY_TIME] > 0)
	{
		@ :diff = time() - CONFIG[AUTO_AWAY_TIME]
		@ :minutes = CONFIG[AUTO_AWAY_TIME] / 60

		if (diff >= AWAY[LAST_INPUT])
		{
			//away -a Auto-away after $minutes minute${minutes > 1 ? [s] : []}.
		}
	}
}


/*
 * This handles the actual writing of messages to your logfile as well
 * as notifying users that you are away.
 */
alias away.process_incoming (type, nick, msg)
{
	if (CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [$strftime(%x %X)] $type [$nick!$userhost()] $msg)
		@ close($fd)

		@ AWAY.NEWMSGS++
	}

	if (CONFIG[SEND_AWAY_NOTICE] && type == [MSG] && finditem(sent_away $nick) < 0)
	{
		@ setitem(sent_away $numitems(sent_away) $nick)
		notice $nick I am currently away. \($A\) [Gone since: $strftime($AWAY.TIME %c)] [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
	}

	return
}


/* bmw '01 */