/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * AWAY.DSM - Away module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 8/29/01 (bmw)
 *
 * This script uses serial number 421 for all ON hooks.
 */

queue cleanup.away
{
	for alias in (away back readlog remlog)
	{
		^alias -$alias
	}

      ^on #msg 421 -"*"
      ^on #notice 421 -"*"
	^on #input 421 -"*"
	^on #timer 421 -"*"
	^on #timer 421 -"12:00"

	@ delarray(sent_away)
}

/*
 * Timestamp for last user input. Needed for auto-away.
 */
@ AWAY.LAST_INPUT = time()

alias away (reason default "$CONFIG.DEFAULT_AWAY_REASON")
{
	if (!A)
	{
		if (CONFIG[AWAY_LOG])
		{
			@ :fd = open($CONFIG.AWAY_LOGFILE w)
			@ write($fd [MsgLog Started $strftime(%c)])
			@ close($fd)
		}

		if (CONFIG[PUBLIC_AWAY])
		{
			if (CONFIG[PUBLIC_AWAY_CHANNELS])
			{
				/* This desparately needs fixing */
				for chan in ($common($CONFIG.PUBLIC_AWAY_CHANNELS / $mychannels()))
				{
					describe $chan is away: $reason [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
				}
			}{
				for chan in ($mychannels())
				{
					describe $chan is away: $reason [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
				}
			}
		}

		/*
		 * Create the hooks needed for message and notice logging.
		 */
		^on #^msg 421 "*"
		{
			if (A)
			{
				@ away.process_incoming(MSG $*)
			}
		}
		^on #^notice 421 "*"
		{
			if (A)
			{
				@ away.process_incoming(NOTICE $*)
			}
		}

		^assign AWAY.TIME $time()
		//away $reason
	}{
		xecho -b You are already away!
	}
}

alias back (reason default "$CONFIG.DEFAULT_BACK_REASON")
{
	if (A)
	{
		if (CONFIG[AWAY_LOG])
		{
			@ :fd = open($CONFIG.AWAY_LOGFILE w)
			@ write($fd [MsgLog Stopped $strftime(%c)])
			@ close($fd)
		}

		if (CONFIG[PUBLIC_AWAY])
		{
			if (CONFIG[PUBLIC_AWAY_CHANNELS])
			{
				for chan in ($common($CONFIG.PUBLIC_AWAY_CHANNELS / $mychannels()))
				{
					describe $chan is back: $reason [Gone since: $strftime($AWAY.TIME %c)]
				}
			}{
				for chan in ($mychannels())
				{
					describe $chan is back: $reason [Gone since: $strftime($AWAY.TIME %c)]
				}
			}
		}

		/*
		 * Cleanup our logging hooks.
		 */
		^on #msg 421 -"*"
		^on #notice 421 -"*"

		@ delarray(sent_away)
		^assign -AWAY.TIME
		//away

		if (AWAY[NEWMSGS])
		{
			xecho -b You have $AWAY.NEWMSGS new message${AWAY[NEWMSGS] > 1 ? [s] : []}.
		}
		
		@ away.prompt_readlog()
	}{
		xecho -b You are not set away.
	}
}

/*
 * This was taken from archon's 'more' script distributed with EPIC
 * http://www.epicsol.org/
 */
alias readlog (void)
{
	if (fexist($CONFIG.AWAY_LOGFILE) == 1)
	{
		@ done = 0
		@ line = 0
		@ fd = open($CONFIG.AWAY_LOGFILE r)
		@ rows = winsize() - 1

		while (!eof($fd) && (pause != [q]))
		{
			while (line++ != rows)
			{
				@ ugh = read($fd)
				if (eof($fd))
				{
					@ done = 1
					@ line = rows
				}{
					echo $ugh
				}
			}

			if (!done)
			{
				^assign pause $"Enter q to quit, or anything else to continue "
				@ line = 0
			}
		}

		@ close($fd)	
		@ fd = line = done = rows = pause = ugh = []
	}{
		xecho -b Logfile [$CONFIG.AWAY_LOGFILE] does not exist.
	}
}

alias remlog (void)
{
	^assign -AWAY.NEWMSGS

	if (fexist($CONFIG.AWAY_LOGFILE))
	{
		@ unlink($CONFIG.AWAY_LOGFILE)
		xecho -b Removed logfile [$CONFIG.AWAY_LOGFILE]
	}{
		xecho -b Logfile [$CONFIG.AWAY_LOGFILE] does not exist.
	}
	
	if (A && CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [MsgLog Started $strftime(%c)])
		@ close($fd)
	}
}

/*
 * Update TS for last input and check for auto-unset-away.
 */
on #^input 421 "*"
{
	@ AWAY.LAST_INPUT = time()
	
	if (A && CONFIG[AUTO_UNSET_AWAY])
	{
		back
	}
}

/*
 * Set ourselves away if auto-away is enabled and we have been idle longer
 * than $CONFIG.AUTO_AWAY_TIME.
 */
on #^timer 421 "*"
{
	if (!A && CONFIG[AUTO_AWAY] && CONFIG[AUTO_AWAY_TIME] > 0)
	{
		@ :diff = time() - CONFIG[AUTO_AWAY_TIME]
		@ :minutes = CONFIG[AUTO_AWAY_TIME] / 60

		if (diff >= AWAY[LAST_INPUT])
		{
			away Auto-away after $minutes minute${minutes > 1 ? [s] : []}.
		}
	}
}

/*
 * Timestamp our logfile at noon if we are away. This is important because
 * logged messages do not contain the date.
 */
on #^timer 421 "12:00"
{
	if (A && CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [TimeStamp $strftime(%c)])
		@ close($fd)
	}
}

/*
 * This handles the actual writing of messages to your logfile as well
 * as notifying users that you are away.
 */
alias away.process_incoming (type, nick, msg)
{
	if (CONFIG[AWAY_LOG])
	{
		@ :fd = open($CONFIG.AWAY_LOGFILE w)
		@ write($fd [$strftime($time() %X)] $type [$nick!$userhost()] $msg)
		@ close($fd)

		@ AWAY.NEWMSGS++
	}

	if (CONFIG[SEND_AWAY_NOTICE] && type == [MSG] && finditem(sent_away $nick) < 0)
	{
		@ setitem(sent_away $numitems(sent_away) $nick)
		notice $nick I am currently away. \($A\) [Gone since: $strftime($AWAY.TIME %c)] [Log/${CONFIG[AWAY_LOG] ? [ON] : [OFF]}]
	}

	return
}

alias away.prompt_readlog (void)
{
	if (AWAY[NEWMSGS])
	{
		input "$INPUT_PROMPT\Would you like to read your msgs now? (y/N) "
		{
			switch ($tolower($mid(0 1 $0)))
			{
				(y) { readlog }
				(*) { # nada }
			}
		}
	}

	return
}


/* bmw '01 */