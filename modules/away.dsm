#version 1.5
/* $Id$ */
/*
 * away.dsm - Away module for DarkStar/EPIC4
 * Copyright (c) 2002, 2003 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 421 for all /ON hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.away {
	^alias -readlog
	^alias -remlog
	^on #305 421 -"*"
	^on #306 421 -"*"
	^on #hook 421 -"CONFIG AWAY_LOG_LEVEL *"
	^on #input 421 -"*"
	^on #msg 421 -"*"
	^on #notice 421 -"*"
	^on #public 421 -'% % *\$servernick()*'
	^on #public_other 421 -'% % *\$servernick()*'
	^on #timer 421 -"*"
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add -b   AUTO_AWAY 1
config.add      AUTO_AWAY_TIME 1200
config.add -b   AUTO_UNSET_AWAY 0
config.add -b   AWAY_LOG 1
eval config.add AWAY_LOGFILE $DS.USER_DIR/away.log
config.add      AWAY_LOG_LEVEL MSGS NOTICES
config.add -b   PUBLIC_AWAY 0
config.add      PUBLIC_AWAY_CHANNELS
config.add -b   SEND_AWAY_NOTICE 1


/****** INIT ******/

/*
 * Timestamp for last user input. Needed for auto-away.
 */
@ AWAY.LAST_INPUT = time()

/*
 * If we're already away when the module is loaded, create a timestamp.
 * This won't be accurate, of course, but it's better than nothing.
 */
for server in ($serverrefs()) {
	if (isaway($server)) {
		@ AWAY.TIME.$server = time()
	}
}


/****** USER ALIASES ******/

alias readlog (file default "$CONFIG.AWAY_LOGFILE", void) {
	@ AWAY.NEWMSGS = []
	if (fexist($file) == 1) {
		less $file
	} else {
		xecho -b Logfile $file does not exist
	}
}

alias remlog (file default "$CONFIG.AWAY_LOGFILE", void) {
	@ AWAY.NEWMSGS = []
	if (fexist($file)) {
		@ unlink($file)
		xecho -b Removed logfile $file
	} else {
		xecho -b Logfile $file does not exist
	}	
}


/****** ON HOOKS ******/

/*
 * You have set yourself away.
 */
on #-306 421 "*" {
	@ :server = servernum($0)
	@ AWAY.TIME.$server = time()
	@ delarray(away.sent_notice.$server)
	if (CONFIG.PUBLIC_AWAY) {
		if (CONFIG.PUBLIC_AWAY_CHANNELS) {
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS) {
				if (match($chan $mychannels($server))) {
					xeval -s $server describe \$chan is away: \$serverctl(GET $server AWAY) [Log/\${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
				}
			}
		} else {
			for chan in ($mychannels($server)) {
				xeval -s $server describe \$chan is away: \$serverctl(GET $server AWAY) [Log/\${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
			}
		}
	}
}

/*
 * You have unset away.
 */
on #-305 421 "*" {
	@ :server = servernum($0)
	@ delarray(away.sent_notice.$server)
	if (CONFIG.PUBLIC_AWAY && AWAY.TIME[$server]) {
		@ :away_time = time() - AWAY.TIME.$server
		if (CONFIG.PUBLIC_AWAY_CHANNELS) {
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS) {
				if (match($chan $mychannels($server))) {
					xeval -s $server describe \$chan is back [Gone \$tdiff($away_time)]
				}
			}
		} else {
			for chan in ($mychannels($server)) {
				xeval -s $server describe \$chan is back [Gone \$tdiff($away_time)]
			}
		}
	}
	if (AWAY.NEWMSGS) {
		xecho -b You have $AWAY.NEWMSGS new message${AWAY.NEWMSGS > 1 ? [s] : []}.
	}
}

/*
 * Restrict the value of the AWAY_LOG_LEVEL config variable.
 */
on #-hook 421 "CONFIG AWAY_LOG_LEVEL *" {
	@ CONFIG.AWAY_LOG_LEVEL = toupper($CONFIG.AWAY_LOG_LEVEL)
	@ :levels = CONFIG.AWAY_LOG_LEVEL
	for lvl in ($levels) {
		if (!match($lvl MSGS NOTICES PUBLICS)) {
			xecho -b Unknown level: $lvl
			xecho -b Valid levels: MSGS NOTICES PUBLICS
			@ :levels = remw($lvl $levels)
		}
	}
	if (levels != CONFIG.AWAY_LOG_LEVEL) {
		@ CONFIG.AWAY_LOG_LEVEL = levels ? levels : [$2-]
		xecho -b Value of AWAY_LOG_LEVEL set to $CONFIG.AWAY_LOG_LEVEL
	}
}

/*
 * Update TS for last input and check for auto-unset-away.
 */
on #-input 421 "*" {
	@ AWAY.LAST_INPUT = time()	
	if (CONFIG.AUTO_UNSET_AWAY) {
		for server in ($serverrefs()) {
			if (isaway($server)) {
				xeval -s $server //away
			}
		}
	}
}

/*
 * Process incoming msgs, notices, and publics appropriately.
 */
on #-msg 421 "*" {
	@ :server = servernum()
	if (isaway($server)) {
		if (CONFIG.SEND_AWAY_NOTICE && finditem(away.sent_notice.$server $0) < 0) {
			@ setitem(away.sent_notice.$server $numitems(away.sent_notice.$server) $0)
			xeval -s $server notice \$0 I am currently away \($serverctl(GET $server AWAY)\) [Gone since: \$strftime($AWAY.TIME[$server] %c)] [Log/\${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
		}
		if (CONFIG.AWAY_LOG && match(MSGS $CONFIG.AWAY_LOG_LEVEL)) {
			if ((:fd = open($CONFIG.AWAY_LOGFILE W)) > -1) {
				@ write($fd [$strftime(%x %X)] MSG <$0!$userhost()> $1-)
				@ close($fd)
			}
			@ AWAY.NEWMSGS++
		}
	}
}

on #-notice 421 "*" {
	@ :server = servernum()
	if (isaway($server) && CONFIG.AWAY_LOG && match(NOTICES $CONFIG.AWAY_LOG_LEVEL)) {
		if ((:fd = open($CONFIG.AWAY_LOGFILE W)) > -1) {
			@ write($fd [$strftime(%x %X)] NOTICE <$0!$userhost()> $1-)
			@ close($fd)
		}
		@ AWAY.NEWMSGS++
	}
}

for hook in (public public_other) {
	^on #-$hook 421 '% % *\$servernick()*' {
		@ :server = servernum()
		if (isaway($server) && CONFIG.AWAY_LOG && match(PUBLICS $CONFIG.AWAY_LOG_LEVEL)) {
			if ((:fd = open($CONFIG.AWAY_LOGFILE W)) > -1) {
				@ write($fd [$strftime(%x %X)] PUBLIC $1 <$0!$userhost()> $2-)
				@ close($fd)
			}
			@ AWAY.NEWMSGS++
		}
	}
}

/*
 * Set ourselves away if auto-away is enabled and we
 * have been idle longer than $CONFIG.AUTO_AWAY_TIME.
 */
on #-timer 421 "*" {
	if (CONFIG.AUTO_AWAY && CONFIG.AUTO_AWAY_TIME > 0) {
		@ :diff = time() - CONFIG.AUTO_AWAY_TIME
		@ :minutes = CONFIG.AUTO_AWAY_TIME / 60
		if (diff >= AWAY.LAST_INPUT) {
			for server in ($serverrefs()) {
				if (!isaway($server)) {
					xeval -s $server //away Auto-away after \$minutes minute\${minutes > 1 ? [s] : []}
				}
			}
		}
	}
}


/* EOF */