#version 1.3.3
/* $Id$ */
/*
 * away.dsm - Away module for DarkStar/EPIC4
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 421 for all /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.away {
	^alias -readlog
	^alias -remlog
	^on #305 421 -"*"
	^on #306 421 -"*"
	^on #hook 421 -"CONFIG AWAY_LOG_LEVEL *"
	^on #input 421 -"*"
	^on #msg 421 -"*"
	^on #notice 421 -"*"
	^on #public 421 -'% % *\$servernick()*'
	^on #public_other 421 -'% % *\$servernick()*'
	^on #timer 421 -"*"
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add -b AUTO_AWAY 1
config.add    AUTO_AWAY_TIME 1200
config.add -b AUTO_UNSET_AWAY 0
config.add -b AWAY_LOG 1
config.add    AWAY_LOGFILE ~/.darkstar/away.log
config.add    AWAY_LOG_LEVEL MSGS NOTICES
config.add -b PUBLIC_AWAY 0
config.add    PUBLIC_AWAY_CHANNELS
config.add -b SEND_AWAY_NOTICE 1


/****** INIT ******/

/*
 * Timestamp for last user input. Needed for auto-away.
 */
@ AWAY.LAST_INPUT = time()

/*
 * If we're already away when the module is loaded, create a timestamp.
 * This won't be accurate, of course, but it's better than nothing.
 */
if (A) {
	@ AWAY.TIME = time()
}


/****** USER ALIASES ******/

alias readlog (file default "$CONFIG.AWAY_LOGFILE", void) {
	@ AWAY.NEWMSGS = []
	if (fexist($file) == 1) {
		less $file
	} else {
		xecho -b Logfile $file does not exist
	}
}

alias remlog (file default "$CONFIG.AWAY_LOGFILE", void) {
	@ AWAY.NEWMSGS = []
	if (fexist($file)) {
		@ unlink($file)
		xecho -b Removed logfile $file
	} else {
		xecho -b Logfile $file does not exist
	}	
}


/****** ON HOOKS ******/

/*
 * You have set yourself away.
 */
on #-306 421 "*" {
	if (CONFIG.PUBLIC_AWAY) {
		@ :server = servernum($0)
		if (CONFIG.PUBLIC_AWAY_CHANNELS) {
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS) {
				if (match($chan $mychannels($server))) {
					describe $chan is away: $A [Log/${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
				}
			}
		} else {
			for chan in ($mychannels($server)) {
				describe $chan is away: $A [Log/${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
			}
		}
	}
	@ delarray(away.sent_away_notice)
	@ AWAY.TIME = time()
}

/*
 * You have unset away.
 */
on #-305 421 "*" {
	if (CONFIG.PUBLIC_AWAY && AWAY.TIME) {
		@ :away_time = time() - AWAY.TIME
		@ :server = servernum($0)
		if (CONFIG.PUBLIC_AWAY_CHANNELS) {
			for chan in ($CONFIG.PUBLIC_AWAY_CHANNELS) {
				if (match($chan $mychannels($server))) {
					describe $chan is back [Gone $tdiff($away_time)]
				}
			}
		} else {
			for chan in ($mychannels($server)) {
				describe $chan is back [Gone $tdiff($away_time)]
			}
		}
	}
	@ delarray(away.sent_away_notice)
	if (AWAY.NEWMSGS) {
		xecho -b You have $AWAY.NEWMSGS new message${AWAY.NEWMSGS > 1 ? [s] : []}.
	}
}

/*
 * Restrict the value of the AWAY_LOG_LEVEL config variable.
 */
on #-hook 421 "CONFIG AWAY_LOG_LEVEL *" {
	@ CONFIG.AWAY_LOG_LEVEL = toupper($CONFIG.AWAY_LOG_LEVEL)
	@ :levels = CONFIG.AWAY_LOG_LEVEL
	for lvl in ($levels) {
		if (!match($lvl MSGS NOTICES PUBLICS)) {
			xecho -b Unknown level: $lvl
			xecho -b Valid levels: MSGS NOTICES PUBLICS
			@ :levels = remw($lvl $levels)
		}
	}
	if (levels != CONFIG.AWAY_LOG_LEVEL) {
		@ CONFIG.AWAY_LOG_LEVEL = levels ? levels : [$2-]
		xecho -b Value of AWAY_LOG_LEVEL set to $CONFIG.AWAY_LOG_LEVEL
	}
}

/*
 * Update TS for last input and check for auto-unset-away.
 */
on #-input 421 "*" {
	@ AWAY.LAST_INPUT = time()	
	if (A && CONFIG.AUTO_UNSET_AWAY) {
		//away -a
	}
}

/*
 * Process incoming msgs, notices, and publics appropriately.
 */
on #-msg 421 "*" {
	if (A) {
		if (CONFIG.SEND_AWAY_NOTICE && finditem(away.sent_away_notice $0) < 0) {
			@ setitem(away.sent_away_notice $numitems(away.sent_away_notice) $0)
			notice $0 I am currently away \($A\) [Gone since: $strftime($AWAY.TIME %c)] [Log/${CONFIG.AWAY_LOG ? [ON] : [OFF]}]
		}
		if (match(MSGS $CONFIG.AWAY_LOG_LEVEL)) {
			away.log MSG $userhost() $* 
		}
	}
}

on #-notice 421 "*" {
	if (A && match(NOTICES $CONFIG.AWAY_LOG_LEVEL)) {
		away.log NOTICE $userhost() $*
	}
}

on #-public 421 '% % *$servernick()*' {
	if (A && match(PUBLICS $CONFIG.AWAY_LOG_LEVEL)) {
		away.log PUBLIC $userhost() $*
	}
}

on #-public_other 421 '% % *$servernick()*' {
	if (A && match(PUBLICS $CONFIG.AWAY_LOG_LEVEL)) {
		away.log PUBLIC $userhost() $*
	}
}

/*
 * Set ourselves away if auto-away is enabled and we
 * have been idle longer than $CONFIG.AUTO_AWAY_TIME.
 */
on #-timer 421 "*" {
	if (!A && CONFIG.AUTO_AWAY && CONFIG.AUTO_AWAY_TIME > 0) {
		@ :diff = time() - CONFIG.AUTO_AWAY_TIME
		@ :minutes = CONFIG.AUTO_AWAY_TIME / 60
		if (diff >= AWAY.LAST_INPUT) {
			//away -a Auto-away after $minutes minute${minutes > 1 ? [s] : []}
		}
	}
}


/****** INTERNAL ALIASES ******/

/*
 * This handles the actual writing of messages to your logfile.
 */
alias away.log (type, userhost, nick, ...) {
	if (type == [PUBLIC]) {
		@ :channel = [$0]
		@ :msg = [$1-]
	} else {
		@ :msg = [$*]
	}
	if (!type || !userhost || !nick || !msg) {
		echo Error: away.log: Not enough arguments
		return
	}
	if (CONFIG.AWAY_LOG) {
		@ :fd = open($CONFIG.AWAY_LOGFILE W)
		if (fd != -1) {
			if (type == [PUBLIC]) {
				@ write($fd [$strftime(%x %X)] $type <$nick!$userhost/$channel> $msg)
			} else {
				@ write($fd [$strftime(%x %X)] $type [$nick!$userhost] $msg)
			}
			@ close($fd)
			@ AWAY.NEWMSGS++
		}
	}
}


/* EOF */