#version 0.8
/* $Id$ */
/*
 * misc.dsm - The 'miscellaneous stuff' module for DarkStar/EPIC4
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 424 for /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.misc
{
	for alias in (dns disco m nslookup ping q tig umode ver whois wi wii ww) {
		^alias -$alias
	}
	for hook in (301 307 $jot(310 315) $jot(317 320) 335 378 ctcp ctcp_reply msg nickname notice send_msg send_notice) {
		^on $hook -"*"
	}
	^on action -'% \$servernick() *'
	^on #connect 424 -"*"
	^on mode -'\$servernick() \$servernick() *' 
	^on send_ctcp -"PRIVMSG *"
	^on #timer 424 -"*"
	^on who -"* % % % % *"
	^on #hook 424 -"CONFIG IGNORE_CTCP_FINGER *"
	^on raw_irc -"% PRIVMSG % :FINGER"
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add    DEFAULT_UMODES iw
config.add -b IGNORE_CTCP_FINGER 1
config.add -b SHOW_AWAY_ONCE 1
config.add    SHOW_AWAY_ONCE_TIMEOUT 900
config.add -b SHOW_HOST_ONCE 1
config.add    SHOW_HOST_ONCE_TIMEOUT 1800

format.add ACTION_USER *> $1 $3-
format.add CTCP $G CTCP $3 from $1: $4-
format.add CTCP_REPLY $G CTCP $3 reply from $1: $4-
format.add MSG *$1* $3-
format.add NICKNAME $G $1 is now known as $2
format.add NOTICE -$1\- $3-
format.add SEND_ACTION_USER * -> $2: $1 $3-
format.add SEND_CTCP
format.add SEND_MSG *$1*> $2-
format.add SEND_NOTICE
format.add WHO $[15]1 $[9]2 $[3]3 $4@$5 \($7-\)
format.add WHO_FOOTER $G $1-
format.add WHO_FOOTER1
format.add WHO_FOOTER2
format.add WHO_HEADER
format.add WHO_HEADER1
format.add WHO_HEADER2
format.add WHOIS_AWAY $G $1 is away: $2-
format.add WHOIS_BOT $G $2 : $3-
format.add WHOIS_CHANNELS $G on channels: $3-
format.add WHOIS_CHANNELS_WRAP
format.add WHOIS_FOOTER $G $2 : End of /WHOIS list.
format.add WHOIS_FOOTER1
format.add WHOIS_FOOTER2
format.add WHOIS_HEADER
format.add WHOIS_HEADER1
format.add WHOIS_HEADER2
format.add WHOIS_HOST $G $2 : $3-
format.add WHOIS_IDENTIFIED $G $2 : $3-
format.add WHOIS_IDLE $G $2 has been idle $tdiff($3), signed on at $strftime($4 %%a %%b %%T %%Z %%Y)
format.add WHOIS_NAME
format.add WHOIS_NICK $G $2 is $3@$4 \($6-\)
format.add WHOIS_OPER $G $2 is being SYN flooded \(IRC Operator\)
format.add WHOIS_SERVER $G on irc via server $1 \($4-\)
format.add WHOIS_SIGNON
format.add WHOWAS_NAME
format.add WHOWAS_NICK $G $2 was $3@$4 \($6-\)
format.add UMODE $G Mode change \"$3-\" for user $2 by $1


/****** USER ALIASES ******/

alias disco disconnect

alias dns (nicks)
{
	if (!nicks) {
		xecho -b Usage: /dns <nick> ...
		return
	}

	for nick in ($nicks) {
		@:uhost = uh($nick)
		if (uhost == [<UNKNOWN>@<UNKNOWN>]) {
			xecho -b User $nick is not online
		} else {
			@:addr = after(-1 @ $uhost)
			@:addr2 = convert($addr)
			xecho -b $nick!$uhost is ${addr2 ? addr2 : [unknown]}
		}
	}
}

alias m msg

alias nslookup
{
	if (![$*]) {
		xecho -b Usage: /nslookup <address> ...
		return
	}

	for addr in ($*) {
		@:tmp = convert($addr)
		xecho -b $addr is ${tmp ? tmp : [unknown]}
	}
}

alias ping (target default "$servernick()", void)
{
	//ping $target
}

alias q query

alias tig (void)
{
	@ delarray(misc.tig)

	/* Grab the ignore list and store it in the misc.tig array. */
	for mask in ($igmask(*)) {
		@ setitem(misc.tig $numitems(misc.tig) $mask $igtype($mask))
	}

	/* Display ignore list. */
	xecho -b Ignorance list:
	for cnt from 0 to ${numitems(misc.tig) - 1} {
		@:line = getitem(misc.tig $cnt)
		@:num = cnt + 1
		echo  $[3]num $[30]word(0 $line) $restw(1 $line)
	}

	^local tmp $"Which ignore(s) to remove? (1, 2-5, ...) "

	/* Remove any of the ignores that the user specified above. */
	for ignum in ($tmp) {
		@:start = before(- $ignum)
		@:end = after(- $ignum)
		if (start < end && start < numitems(misc.tig) && end <= numitems(misc.tig)) {
			for cnt from $start to $end {
				//ignore $word(0 $getitem(misc.tig ${cnt - 1})) NONE
			}
		} else if (ignum <= numitems(misc.tig)) {
			//ignore $word(0 $getitem(misc.tig ${ignum - 1})) NONE
		}
	}
}

alias umode (mode)
{
	//mode $servernick() $mode
}

alias ver (nick default "$servernick()", void)
{
	ctcp $nick version
}

alias wi whois
alias whois (args)
{
	@:item = matchitem(misc.away_users $word(0 $args))
	if (item > -1) {
		@ delitem(misc.away_users $item)
		@ delitem(misc.away_users_ts $item)
	}
	//whois $args
}

alias wii (nick default "$servernick()", void)
{
	whois $nick $nick
}

alias ww whowas


/****** ON HOOKS ******/

on ^301 "*"
{
	if (FORMAT.WHOIS_AWAY) {
		if (CONFIG.SHOW_AWAY_ONCE) {
			if (matchitem(misc.away_users $0) < 0) {
				echo $fparse(WHOIS_AWAY $*)
				@ setitem(misc.away_users $numitems(misc.away_users) $0)
				@ setitem(misc.away_users_ts $numitems(misc.away_users_ts) $time())
			}
		} else {
			echo $fparse(WHOIS_AWAY $*)
		}
	}
}

/*
 * For DALnet and servers running UnrealIRCd.
 * Shows you that the user has identified with services.
 */
on ^307 "*"
{
	if (FORMAT.WHOIS_IDENTIFIED) {
		echo $fparse(WHOIS_IDENTIFIED $*)
	}
}

on ^310 "*" #

on ^311 "*"
{
	for var in (WHOIS_HEADER WHOIS_HEADER1 WHOIS_HEADER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
	if (FORMAT.WHOIS_NICK) {
		echo $fparse(WHOIS_NICK $*)
	}
	if (FORMAT.WHOIS_NAME) {
		echo $fparse(WHOIS_NAME $*)
	}
}

on ^312 "*"
{
	if (FORMAT.WHOIS_SERVER) {
		echo $fparse(WHOIS_SERVER $*)
	}
}

on ^313 "*"
{
	if (FORMAT.WHOIS_OPER) {
		echo $fparse(WHOIS_OPER $*)
	}
}

on ^314 "*"
{
	for var in (WHOIS_HEADER WHOIS_HEADER1 WHOIS_HEADER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
	if (FORMAT.WHOWAS_NICK) {
		echo $fparse(WHOWAS_NICK $*)
	}
	if (FORMAT.WHOWAS_NAME) {
		echo $fparse(WHOWAS_NAME $*)
	}
}

on ^315 "*"
{
	for var in (WHO_FOOTER WHO_FOOTER1 WHO_FOOTER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
	^assign -MISC.WHO_HEADER_DONE
}

on ^317 "*"
{
	if (FORMAT.WHOIS_IDLE) {
		echo $fparse(WHOIS_IDLE $*)
	}
	if (FORMAT.WHOIS_SIGNON) {
		echo $fparse(WHOIS_SIGNON $*)
	}
}

on ^318 "*"
{
	for var in (WHOIS_FOOTER WHOIS_FOOTER1 WHOIS_FOOTER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
}

on ^319 "*"
{
	if (FORMAT.WHOIS_CHANNELS_WRAP) {
		/*
		 * Okay, here we go... The following attempts to do some
		 * intelligent line wrapping with the list of channels returned
		 * for a WHOIS request. It will fit as many channels per line
		 * as possible, _after_ being passed through $fparse(). If a
		 * single channel is larger than what can be displayed on one
		 * line, we give up and let EPIC handle it.
		 *
		 * NOTE: The WHOIS_CHANNELS variable will still be used for
		 * the first line, and the WHOIS_CHANNELS_WRAP variable will
		 * be used for all proceeding lines.
		 */

		^local format_var WHOIS_CHANNELS
		^local channels

		for chan in ($2-) {
			if (!channels) {
				push channels $chan
			} else if (no_fit && strlen($fparse($format_var $0 $1 $channels)) >= word(0 $geom())) {
				echo $fparse($format_var $0 $1 $channels)
				@:channels = chan
				@:no_fit = []
			} else if (strlen($fparse($format_var $0 $1 $channels $chan)) >= word(0 $geom())) {
				echo $fparse($format_var $0 $1 $channels)
				@:channels = chan
				@:format_var = [WHOIS_CHANNELS_WRAP]
				@:no_fit = 1
			} else {
				push channels $chan
			}
		}

		if (channels) {
			echo $fparse($format_var $0 $1 $channels)
		}
	}{
		/*
		 * Don't do anything special with the list of channels,
		 * just output everything on a single line.
		 */
		if (FORMAT.WHOIS_CHANNELS) {
			echo $fparse(WHOIS_CHANNELS $*)
		}
	}
}

/*
 * OPN
 */
on ^320 "*"
{
	if (FORMAT.WHOIS_IDENTIFIED) {
		echo $fparse(WHOIS_IDENTIFIED $*)
	}
}

/*
 * UnrealIRCd's WHOISBOT numeric
 */
on ^335 "*"
{
	if (FORMAT.WHOIS_BOT) {
		echo $fparse(WHOIS_BOT $*)
	}
}

on ^369 "*"
{
	for var in (WHOIS_FOOTER WHOIS_FOOTER1 WHOIS_FOOTER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
}

/*
 * UnrealIRCd's WHOISHOST
 */
on ^378 "*"
{
	if (FORMAT.WHOIS_HOST) {
		echo $fparse(WHOIS_HOST $*)
	}
}

/*
 * Default user modes
 */
on #^connect 424 "*" //mode $servernick() $CONFIG.DEFAULT_UMODES

on ^action '% $servernick() *'
{
	if (FORMAT.ACTION_USER) {
		echo $fparse(ACTION_USER $*)
	}
}

on ^ctcp "*"
{
	if (FORMAT.CTCP) {
		echo $fparse(CTCP $*)
	}
}

on ^ctcp_reply "*"
{
	if (FORMAT.CTCP_REPLY) {
		echo $fparse(CTCP_REPLY $*)
	}
}

on ^mode '$servernick() $servernick() *'
{
	if (FORMAT.UMODE) {
		echo $fparse(UMODE $*)
	}
}

on ^msg "*"
{
	if (FORMAT.MSG) {
		if (CONFIG.SHOW_HOST_ONCE) {
			if (finditem(misc.userhosts $0 $userhost()) < 0) {
				@:uhost = userhost()
				@ setitem(misc.userhosts $numitems(misc.userhosts) $0 $uhost)
				@ setitem(misc.userhosts_ts $numitems(misc.userhosts_ts) $time())
			} else {
				@:uhost = [*]
			}
			echo $fparse(MSG $0 $uhost $1-)
		} else {
			echo $fparse(MSG $0 $userhost() $1-)
		}
	}
}

on ^nickname "*"
{
	if (FORMAT.NICKNAME) {
		echo $fparse(NICKNAME $*)
	}
}

on ^notice "*"
{
	if (FORMAT.NOTICE) {
		if (CONFIG.SHOW_HOST_ONCE) {
			if (finditem(misc.userhosts $0 $userhost()) < 0) {
				@:uhost = userhost()
				@ setitem(misc.userhosts $numitems(misc.userhosts) $0 $uhost)
				@ setitem(misc.userhosts_ts $numitems(misc.userhosts_ts) $time())
			} else {
				@:uhost = [*]
			}
			echo $fparse(NOTICE $0 $uhost $1-)
		} else {
			echo $fparse(NOTICE $0 $userhost() $1-)
		}
	}
}

on ?raw_irc "% PRIVMSG % :FINGER"
{
	if (CONFIG.IGNORE_CTCP_FINGER) {
		xecho -b CTCP FINGER request received from $before(1 ! $0), ignoring...
		return 1
	} else {
		return 0
	}
}

on ^send_action "*"
{
	if (FORMAT.SEND_ACTION_USER) {
		echo $fparse(SEND_ACTION_USER $servernick() $*)
	}
}

on ^send_ctcp "PRIVMSG *"
{
	if (FORMAT.SEND_CTCP && [$2] != [ACTION]) {
		echo $fparse(SEND_CTCP $*)
	}
}

on ^send_msg "*"
{
	if (FORMAT.SEND_MSG) {
		echo $fparse(SEND_MSG $*)
	}
}

on ^send_notice "*"
{
	if (FORMAT.SEND_NOTICE) {
		echo $fparse(SEND_NOTICE $*)
	}
}

/*
 * Add a timeout for SHOW_AWAY_ONCE and SHOW_HOST_ONCE.
 */
on #-timer 424 "*"
{
	^local delete
	for cnt from 0 to ${numitems(misc.away_users_ts) - 1} {
		@:ts = getitem(misc.away_users_ts $cnt)
		if ((time() - ts) > CONFIG.SHOW_AWAY_ONCE_TIMEOUT) {
			push delete $cnt
		}
	}
	for item in ($reverse($delete)) {
		@ delitem(misc.away_users $item)
		@ delitem(misc.away_users_ts $item)
	}

	^local delete2
	for cnt from 0 to ${numitems(misc.userhosts_ts) - 1} {
		@:ts = getitem(misc.userhosts_ts $cnt)
		if ((time() - ts) > CONFIG.SHOW_HOST_ONCE_TIMEOUT) {
			push delete2 $cnt
		}
	}
	for item in ($reverse($delete2)) {
		@ delitem(misc.userhosts $item)
		@ delitem(misc.userhosts_ts $item)
	}
}

on ^who "* % % % % *"
{
	if (!MISC.WHO_HEADER_DONE) {
		for var in (WHO_HEADER WHO_HEADER1 WHO_HEADER2) {
			if (FORMAT[$var]) {
				echo $fparse($var $*)
			}
		}

		/*
		 * This prevents the header from being displayed more than once.
		 * It is removed by the WHO_FOOTER hook (315).
		 */
		@ MISC.WHO_HEADER_DONE = 1
	}

	if (FORMAT.WHO) {
		echo $fparse(WHO $*)
	}
}


/* EOF */