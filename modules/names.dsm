#version 0.5
/* $Id$ */
/*
 * names.dsm - DarkStar/EPIC4 module to display who's on a channel
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 428 for /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.names
{
	for alias in (names sc scan scann scano scanv) {
		^alias -$alias
	}
	^on 353 -"*"
	^on 366 -"*"
	^on #hook 428 -"CONFIG NAMES_COL *"
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add    NAMES_COL
config.add -b NAMES_SORT_BY_MODE 0

format.add NAMES_FOOTER
format.add NAMES_FOOTER1
format.add NAMES_FOOTER2
format.add NAMES_HEADER
format.add NAMES_HEADER1
format.add NAMES_HEADER2
format.add NAMES_LEFT $G Users on $1:
format.add NAMES_MID
format.add NAMES_NONOP $1
format.add NAMES_OP @$1
format.add NAMES_RIGHT
format.add NAMES_VOICE +$1


/****** USER ALIASES ******/

alias names scan
alias sc scan
alias scan  (chan default "$C", void) {names.main $chan}
alias scann (chan default "$C", void) {names.main $chan n}
alias scano (chan default "$C", void) {names.main $chan o}
alias scanv (chan default "$C", void) {names.main $chan v}


/****** INTERNAL ALIASES ******/

/*
 * This does most of the real work. It is a bit more expensive than
 * I would like it to be, but it allows for greater customization.
 */
alias names.main (chan default "$C", mode default "*", void)
{
	/*
	 * Compile the list of users that we want to display.
	 * This is also where any sorting takes place.
	 */
	^local users
	switch ($tolower($mode))
	{
		(n) {
			@:desc = [normal users]
			@:users = nochops($chan)
		}
		(o) {
			@:desc = [channel operators]
			@:users = chops($chan)
		}
		(v) {
			^local desc voiced users
			for nick in ($channel($chan)) {
				if (mid(1 1 $nick) == [+]) {
					push users $rest(2 $nick)
				}
			}
		}
		(*) {
			@:desc = [users]
			if (CONFIG.NAMES_SORT_BY_MODE) {
				push users $chops($chan)
				push users $nochops($chan)
			} else {
				push users $onchannel($chan)
			}
		}
	}

	if (#users < 1) {
		xecho -b No $desc found on channel $chan
		return 0
	}

	/*
	 * Display the header, if any.
	 */
	for var in (NAMES_HEADER NAMES_HEADER1 NAMES_HEADER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $chan $#onchannel($chan) $#chops($chan) $#nochops($chan))
		}
	}

	if (CONFIG.NAMES_COL)
	{
		/*
		 * Create a temporary variable to store the names of the
		 * variables we'll be using in the /FE below. This allows us
		 * to resize the number of columns in the output according to
		 * the NAMES_COL config variable.
		 */
		^local tmp
		for cnt from 1 to $CONFIG.NAMES_COL {
			push tmp nick.$cnt
		}

		/*
		 * Break the list of users into multiple lines. This gets
		 * a little tricky because we want certain things evaluated
		 * before others.
		 */
		fe ($users) $tmp
		{
			^local line

			if (FORMAT.NAMES_LEFT) {
				push line \$fparse(NAMES_LEFT $chan $#onchannel($chan) $#chops($chan) $#nochops($chan))
			}

			for (@:cnt = 1, cnt <= numwords($tmp), @:cnt++)
			{
				/*
				 * The call to $names.parse() doesn't actually
				 * happen until the last line of the /FE code block
				 */
				eval push line \\\$names.parse\(\$chan \$nick[$cnt]\)

				/*
				 * Insert NAMES_MID inbetween each nick, if it exists.
				 * We check for NAMES_RIGHT because we don't want to
				 * add NAMES_MID for nicknames that aren't there
				 * unless we have an outer border. This is way more
				 * work than I want to do here, but it seems to be
				 * the only way to get correct behavior.
				 */
				if (FORMAT.NAMES_MID) {
					if (FORMAT.NAMES_RIGHT) {
						unless (cnt == CONFIG.NAMES_COL) {
							push line \$FORMAT.NAMES_MID
						}
					} else {
						@:next = cnt + 1
						if (nick[$next]) {
							push line \$FORMAT.NAMES_MID
						}
					}
				}
			}

			if (FORMAT.NAMES_RIGHT) {
				push line \$fparse(NAMES_RIGHT $chan $#onchannel($chan) $#chops($chan) $#nochops($chan))
			}

			eval echo $line
		}
	}{
		^local line
		if (FORMAT.NAMES_LEFT) {
			push line $fparse(NAMES_LEFT $chan $#onchannel($chan) $#chops($chan) $#nochops($chan))
		}
		for nick in ($users) {
			push line $names.parse($chan $nick)
		}
		echo $line
	}

	/*
	 * Display footer, if any.
	 */
	for var in (NAMES_FOOTER NAMES_FOOTER1 NAMES_FOOTER2) {
		if (FORMAT[$var]) {
			echo $fparse($var $chan $#onchannel($chan) $#chops($chan) $#nochops($chan))
		}
	}
}

/*
 * This returns a formatted string for the nick passed to it,
 * suitable for final display, according to whether they have
 * +o or +v on the channel.
 */
alias names.parse (chan, nick, void)
{
	if (!chan || !nick) {
		@ function_return = fparse(NAMES_NONOP $nick)
	} else if (ischanop($nick $chan)) {
		@ function_return = fparse(NAMES_OP $nick)
	} else if (ischanvoice($nick $chan) == 1) {
		@ function_return = fparse(NAMES_VOICE $nick)
	} else {
		@ function_return = fparse(NAMES_NONOP $nick)
	}
}


/****** ON HOOKS ******/

/*
 * Hook the NAMES numerics and call names.main
 */
on ^353 "*"
{
	^assign NAMES.CHAN $2
}

on ^366 "*"
{
	names.main $NAMES.CHAN
	^assign -NAMES.CHAN
}

/*
 * Restrict the value of the NAMES_COL config variable.
 */
on #-hook 428 "CONFIG NAMES_COL *"
{
	if (!isnumber($CONFIG.NAMES_COL b10) && CONFIG.NAMES_COL) {
		xecho -b Value must be an integer
		^assign CONFIG.NAMES_COL $2
		xecho -b Value of NAMES_COL set back to $2
	}
}


/* EOF */