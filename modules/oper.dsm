#version 0.5.2
/* $Id$ */
/*
 * oper.dsm - IRC Operator module for DarkStar/EPIC4
 * Copyright (c) 2002, 2003 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 427 for all /ON hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.oper
{
	^alias -challenge
	^alias -operview
	^alias -operwall

	^on #381 427 -"*"
	^on #464 427 -"*"
	^on #connect 427 -"*"
	^on #hook 427 -"CONFIG OPERVIEW *"
	^on #hook 427 -"CONFIG OPERVIEW_HIDDEN *"
	^on #hook 427 -"CONFIG OPERVIEW_LEVEL *"
	^on #hook 427 -"CONFIG OPERVIEW_SIZE *"
	^on #hook 427 -"LOADMOD tabkey"
	^on #timer 427 -"*"
	^on wallop -"*"
	^on #window_create 427 -"*"
	^on #window_kill 427 -"*"
	^on #window_kill 427 -"operview"

	oper.operview.destroy

	if (OPER.CHALLENGE.ACTIVE) {
		oper.challenge.cleanup $OPER.CHALLENGE.ACTIVE
	}
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add -b AUTO_CHALLENGE 0
config.add    CHALLENGE_RSA_RESPOND
config.add    OPER_UMODES wzsky
config.add -b OPERVIEW 0
config.add -b OPERVIEW_HIDDEN 0
config.add    OPERVIEW_LEVEL opnotes,snotes,wallops
config.add    OPERVIEW_SIZE 5

format.add WALLOP !$1$2! $3-


/****** INIT ******/

/*
 * Force the loading of saved settings early so that
 * the /IF commands in the STARTUP section can use them.
 */
module.load_saved_settings


/****** USER ALIASES ******/

/*
 * Support for ircd-ratbox and hybrid7's challenge-response opering.
 *
 * Usage:
 *  /CHALLENGE -add <server> <nick> <key>
 *  /CHALLENGE -del <server>
 *  /CHALLENGE -list
 *  /CHALLENGE [nick]
 *
 * Note: There must be an entry for the current server in the
 * challenge-response list before this command can be used to gain
 * oper priveleges.
 */
alias challenge (...)
{
	switch ($0)
	{
		(-a) (-add)
		{
			if (![$3])
			{
				xecho -b Usage: /CHALLENGE -add <server> <nick> <key>
				return
			}

			switch ($oper.challenge.add($1-))
			{
				(1) { xecho -b Entry for $1 added to challenge-response list; }
				(*) { xecho -b Failed to add entry for $1 to challenge-response list; }
			}
		}

		(-d) (-del) (-delete)
		{
			if (![$1])
			{
				xecho -b Usage: /CHALLENGE -delete <server>
				return
			}

			switch ($oper.challenge.delete($1))
			{
				(1) { xecho -b Deleted $1 from the challenge-response list; }
				(*) { xecho -b Failed to delete $1 from the challenge-response list; }
			}
		}

		(-l) (-list)
		{
			oper.challenge.list
		}

		(*)
		{
			if (fexist($CONFIG.CHALLENGE_RSA_RESPOND) == -1)
			{
				xecho -b Invalid rsa_respond path. Aborting challenge.
				return
			}

			oper.challenge $servername() $*
		}
	}
}

alias operview (...)
{
	if ([$0]) {
		dset OPERVIEW $0
	} else {
		dset OPERVIEW ${CONFIG.OPERVIEW ? 0 : 1}
	}
}

alias operwall (text)
{
	if (text) {
		//quote operwall :$text
	} else {
		xecho -b Usage: /OPERWALL <text>
	}
}


/****** INTERNAL ALIASES ******/

alias oper.add_tabcomp (void)
{
	^alias tabkey.cmd.challenge (...)
	{
		bless
		if (curword == 1)
		{
			@ :tmp = [-ADD -DELETE -LIST]
			push tmp $tabkey.method.nick($*)
			@ :matches = pattern("$0*" $tmp)
			@ function_return = matches ? matches : [ ]
		}\
		else if (curword == 2)
		{
			^local servernames
			if (match($word(1 $L) -a -add))
			{
				for serv in ($serverrefs())
				{
					if (serv > -1 && (:servname = servername($serv)) != [<none>]) {
						push servernames $servname
					}
				}
			}\
			else if (match($word(1 $L) -d -del -delete))
			{
				for cnt from 1 to $numitems(oper.challenge) {
					push servernames $word(0 $getitem(oper.challenge ${cnt-1}))
				}
			}{
				/* Disable completion */
				@ :servernames = [ ]
			}
			@ :matches = pattern("$0*" $servernames)
			@ function_return = matches ? matches : [ ]
		}\
		else if (curword == 4)
		{
			@ function_return = tabkey.method.file($*)
		}{
			@ function_return = tabkey.method.nick($*)
		}
	}
}

/*
 * This does all the real work for challenge-response authentication.
 *
 * To prevent multiple challenges from interfering with each other, the
 * global variable OPER.CHALLENGE.ACTIVE will be set to the name of the
 * server to which the active challenge belongs and will be removed by the
 * oper.challenge.cleanup alias. This also allows us to use /INPUT, with
 * the -noecho option, instead of $"..." to get the user's password.
 */
alias oper.challenge (serv, nick, void)
{
	if (!nick || OPER.CHALLENGE.ACTIVE || fexist($CONFIG.CHALLENGE_RSA_RESPOND) == -1) {
		return
	}

	@ :item = matchitem(oper.challenge $serv *)
	if (item > -1)
	{
		/*
		 * Challenge reply from server.
		 */
		^on ^386 "$serv *"
		{
			xecho -b Received challenge reply from $0. Generating response...
			@ :item = matchitem(oper.challenge $0 *)
			@ :tmp = getitem(oper.challenge $item)
			@ :key = word(2 $tmp)
			exec -name challenge.$servernum($serv) $CONFIG.CHALLENGE_RSA_RESPOND $key $1
		}

		/*
		 * User does not have oper priveleges.
		 */
		^on #-491 427 "$serv *"
		{
			oper.challenge.cleanup $0
		}

		/*
		 * Catch the response generated by the rsa_respond utility.
		 */
		^on ^exec "challenge.$servernum($serv) *"
		{
			if ([$1])
			{
				@ :servernum = after(1 . $0)
				xecho -w $serverwin($servernum) -b Sending challenge response to $servername($servernum)
				xeval -s $servernum -- quote challenge +$1-
			}
		}

		/*
		 * Keep exec_exit quiet and cleanup after everything.
		 */
		^on ^exec_exit "challenge.$servernum($serv) *"
		{
			oper.challenge.cleanup $servername($after(1 . $0))
		}

		/*
		 * If the key requires a password, prompt the user.
		 */
		^on ^exec_prompt "challenge.$servernum($serv) Enter passphrase for challenge*"
		{
			@ :serv = servername($after(1 . $0))
			@ :item = matchitem(oper.challenge $serv *)
			@ :key = word(2 $getitem(oper.challenge $item))
			input -noecho "Enter passphrase for $key: "
			{
				^exec -in %challenge.$servernum($OPER.CHALLENGE.ACTIVE) ${[$*] ? [$*] : [-]}
			}
		}

		^on #-server_notice 427 "$serv *PK authentication is not enabled*"
		{
			oper.challenge.cleanup $0
		}

		/* Start the party... */
		@ OPER.CHALLENGE.ACTIVE = serv
		xecho -b Initiating challenge-response with $serv for $nick
		xeval -s $serv -- quote challenge $nick
	}{
		xecho -b No entry for $serv in the challenge-response list
		xecho -b You can add entries with: /CHALLENGE -add <server> <nick> <key>
		xecho -b For manual challenge-response authentication use /QUOTE CHALLENGE
	}
}

alias oper.challenge.add (serv, nick, key, void)
{
	if (!key) {
		return
	}

	@ :item = matchitem(oper.challenge $serv *)
	if (item > -1)
	{
		^local ask $'There is already an entry for $serv - Overwrite? '
		if (ask == [y])
		{
			@ setitem(oper.challenge $item $serv $nick $key)
			oper.challenge.write
			return 1
		}
	}{
		@ setitem(oper.challenge $numitems(oper.challenge) $serv $nick $key)
		oper.challenge.write
		return 1
	}
}

alias oper.challenge.cleanup (serv, void)
{
	if (!serv) {
		return
	}

	^on 386 -"$serv *"
	^on #491 427 -"$serv *"
	^on exec -"challenge.$servernum($serv) *"
	^on exec_exit -"challenge.$servernum($serv) *"
	^on exec_prompt -"challenge.$servernum($serv) Enter passphrase for challenge*"
	^on #server_notice 427 -"$serv *PK authentication is not enabled*"
	^assign -OPER.CHALLENGE.ACTIVE
}

alias oper.challenge.delete (serv, void)
{
	if (!serv) {
		return
	}

	@ :item = matchitem(oper.challenge $serv *)
	if (item > -1)
	{
		@ delitem(oper.challenge $item)
		oper.challenge.write
		return 1
	}{
		return 0
	}
}

alias oper.challenge.list (void)
{
	if (numitems(oper.challenge))
	{
		xecho -b Challenge-response list:
		echo Server                     Nick         Key
		for cnt from 1 to $numitems(oper.challenge)
		{
			@ :tmp  = getitem(oper.challenge ${cnt-1})
			@ :serv = word(0 $tmp)
			@ :nick = word(1 $tmp)
			@ :key  = word(2 $tmp)
			echo $[26]serv $[12]nick $key
		}
	}{
		xecho -b There are no entries in the challenge-response list
	}
}

alias oper.challenge.readdb (file default "$DS.USER_DIR/challenge.sav", void)
{
	if (fexist($file) == 1)
	{
		@ :fd = open($file R)
		if (fd != -1)
		{
			@ delarray(oper.challenge)
			while (!eof($fd))
			{
				@ :line = read($fd)
				if (line != []) {
					@ setitem(oper.challenge $numitems(oper.challenge) $line)
				}
			}
			@ close($fd)
		}
	}
}

alias oper.challenge.writedb (file default "$DS.USER_DIR/challenge.sav", void)
{
	@ unlink($file)
	@ :fd = open($file W)
	if (fd == -1)
	{
		echo Error: oper.challenge.writedb: Unable to write to $file
		return
	}
	for cnt from 1 to $numitems(oper.challenge)
	{
		@ :item = cnt - 1
		@ write($fd $getitem(oper.challenge $item))
	}
	@ close($fd)
}

alias oper.operview.create (void)
{
	if (winnum(operview) == -1)
	{
		window new name operview
		oper.operview.fix
	}
}

alias oper.operview.destroy (void)
{
	if (winnum(operview) != -1) {
		window operview kill
	}
	if ((:item = matchitem(single_status operview)) > -1) {
		@ delitem(single_status $item)
	}
}

alias oper.operview.fix (void)
{
	if (winnum(operview) == -1) {
		return
	}

	window operview level $CONFIG.OPERVIEW_LEVEL

	if (CONFIG.OPERVIEW_HIDDEN)
	{
		window operview hide
		if (STATUS.DOUBLE) {
			window operview double on
		}
		if ((:item = matchitem(single_status operview)) > -1) {
			@ delitem(single_status $item)
		}
	}{
		/*
		 * Make sure that the operview window is visible but
		 * never becomes the active window.
		 */
		if (!winvisible(operview)) {
			window show operview
		}

		if (winnam() == [operview])
		{
			^local visible
			for wref in ($winrefs())
			{
				if (winvisible($wref)) {
					push visible $wref
				}
			}

			if (#visible == 1)
			{
				window previous
				window show operview
				window last
			}{
				for wref in ($visible)
				{
					if (!match($winnam($wref) operview msgs))
					{
						window refnum $wref
						break
					}
				}
			}
		}

		window operview double off fixed on size $CONFIG.OPERVIEW_SIZE

		if (finditem(single_status operview) < 0) {
			@ setitem(single_status $numitems(single_status) operview)
		}
	}
}


/****** ON HOOKS ******/

on #-381 427 "*"
{
	//mode $servernick() $CONFIG.OPER_UMODES
	^assign -OPER.FAILED.$servernum()
}

/*
 * Keep track of failed oper attempts so that the auto-challenge
 * feature can ignore them.
 */
on #-464 427 "*"
{
	@ OPER.FAILED.$servernum($0) = time()
}

on #-connect 427 "*"
{
	if (CONFIG.AUTO_CHALLENGE)
	{
		@ :item = matchitem(oper.challenge $2 *)
		if (item > -1)
		{
			@ :nick = word(1 $getitem(oper.challenge $item))
			xeval -s $servernum($2) -- challenge $nick
		}
	}
}

on #-hook 427 "CONFIG OPERVIEW *"
{
	if (CONFIG.OPERVIEW) {
		oper.operview.create
	} else {
		oper.operview.destroy
	}
}

on #-hook 427 "CONFIG OPERVIEW_HIDDEN *"
{
	oper.operview.fix
}

on #-hook 427 "CONFIG OPERVIEW_LEVEL *"
{
	@ :bad = :good = []
	@ :levels = [ACTIONS CRAP CTCP DCC MSGS NOTES NOTICES OPNOTES PUBLIC SNOTES USERLOG1 USERLOG2 USERLOG3 USERLOG4 WALLOPS WALLS]
	for lvl in ($split(, $CONFIG.OPERVIEW_LEVEL))
	{
		if (findw($lvl $levels) > -1) {
			push good $lvl
		} else {
			push bad $lvl
		}
	}

	if (bad)
	{
		for lvl in ($bad) {
			xecho -b Unknown level: $toupper($lvl)
		}
		xecho -b Valid levels: $levels
		if (good) {
			@ :newlevels = unsplit(, $good)
		} else {
			@ :newlevels = [$2-]
		}
		^assign CONFIG.OPERVIEW_LEVEL $toupper($newlevels)
		xecho -b Value of OPERVIEW_LEVEL set to $CONFIG.OPERVIEW_LEVEL
	}{
		^assign CONFIG.OPERVIEW_LEVEL $toupper($CONFIG.OPERVIEW_LEVEL)
	}

	if (CONFIG.OPERVIEW) {
		window operview level $CONFIG.OPERVIEW_LEVEL
	}
}

on #-hook 427 "CONFIG OPERVIEW_SIZE *"
{
	@ :size = CONFIG.OPERVIEW_SIZE
	@ :max_size = word(1 $geom()) - 4
	if (!isnumber($size b10) || size < 1 || size > max_size)
	{
		xecho -b Value must be an integer greater than 0 and no larger than $max_size
		^assign CONFIG.OPERVIEW_SIZE $2
		xecho -b Value of OPERVIEW_SIZE set to $CONFIG.OPERVIEW_SIZE
	}
	if (CONFIG.OPERVIEW && !CONFIG.OPERVIEW_HIDDEN) {
		window operview size $CONFIG.OPERVIEW_SIZE
	}
}

on #-hook 427 "LOADMOD tabkey"
{
	oper.add_tabcomp
}

/*
 * Check each server to see if we should auto-challenge.
 *
 * Failed oper attempts, either with /OPER or /CHALLENGE, will cause
 * auto-challenge to ignore that server for 20 minutes.
 */
on #-timer 427 "*"
{
	if (CONFIG.AUTO_CHALLENGE && !OPER.CHALLENGE.ACTIVE)
	{
		foreach OPER.FAILED member
		{
			@ :diff = time() - OPER[FAILED][$member]
			if (diff > 1200) {
				^assign -OPER.FAILED.$member
			}
		}

		for serv in ($serverrefs())
		{
			@ :servname = servername($serv)
			@ :item = matchitem(oper.challenge $servname *)
			if (serv > -1 && item > -1 && !OPER[FAILED][$serv])
			{
				if (!pass(oO $usermode($serv)))
				{
					@ :nick = word(1 $getitem(oper.challenge $item))
					xeval -s $serv -- challenge $nick
				}
			}
		}
	}
}

on ^wallop "*"
{
	if (FORMAT.WALLOP) {
		echo $fparse(WALLOP $*)
	}
}

on #-window_create 427 "*"
{
	oper.operview.fix
}

on #-window_kill 427 "*"
{
	oper.operview.fix
}

on #-window_kill 427 "operview"
{
    if (CONFIG.OPERVIEW) {
        dset OPERVIEW OFF
    }
}


/****** STARTUP ******/

if (isloaded(tabkey)) {
	oper.add_tabcomp
}

if (CONFIG.OPERVIEW) {
	oper.operview.create
}

oper.challenge.readdb


/* EOF */