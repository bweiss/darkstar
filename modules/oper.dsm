#version 0.4
/* $Id$ */
/*
 * oper.dsm - IRC Operator module for DarkStar/EPIC4
 * Copyright (c) 2002, 2003 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 427 for all /ON hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.oper
{
	^alias -challenge
	^alias -operview
	^alias -operwall

	^on #381 427 -"*"
	^on 386 -"*"
	^on #connect 427 -"*"
	^on #hook 427 -"CONFIG OPERVIEW *"
	^on #hook 427 -"CONFIG OPERVIEW_HIDDEN *"
	^on #hook 427 -"CONFIG OPERVIEW_LEVEL *"
	^on #hook 427 -"CONFIG OPERVIEW_SIZE *"
	^on #hook 427 -"LOADMOD tabkey"
	^on #timer 427 -"*"
	^on wallop -"*"
	^on #window_create 427 -"*"
	^on #window_kill 427 -"*"
	^on #window_kill 427 -"operview"

	oper.operview.destroy
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add -b AUTO_CHALLENGE 0
config.add    CHALLENGE_RSA_RESPOND
config.add    OPER_UMODES wzsky
config.add -b OPERVIEW 0
config.add -b OPERVIEW_HIDDEN 0
config.add    OPERVIEW_LEVEL opnotes,snotes,wallops
config.add    OPERVIEW_SIZE 5

format.add WALLOP !$1$2! $3-


/****** INIT ******/

/*
 * Force the loading of saved settings early so that
 * the /IF commands in the STARTUP section can use them.
 */
module.load_saved_settings


/****** USER ALIASES ******/

/*
 * /CHALLENGE -add <server> <nick> <key>
 * /CHALLENGE -del <server>
 * /CHALLENGE -list
 * /CHALLENGE [nick]
 */
alias challenge (...)
{
	switch ($0)
	{
		(-a) (-add)
		{
			@ :servname = [$1]
			@ :nick     = [$2]
			@ :key      = [$3]

			if (!key)
			{
				xecho -b Usage: /CHALLENGE -add <server> <nick> <key>
				return
			}

			if ((:item = matchitem(oper.challenge $servname *)) > -1)
			{
				^local ask $'There is already an entry for $servname. Overwrite? '
				if (ask == [y])
				{
					@ setitem(oper.challenge $item $servname $nick $key)
					xecho -b Challenge added for $servname
					oper.write_clist
				}
			}{
				@ setitem(oper.challenge $numitems(oper.challenge) $servname $nick $key)
				xecho -b Challenge added for $servname
				oper.write_clist
			}

		}

		(-d) (-del) (-delete)
		{
			@ :servname = [$1]
			if ((:item = matchitem(oper.challenge $servname *)) > -1)
			{
				@ delitem(oper.challenge $item)
				xecho -b Deleted $servname from challenge list
				oper.write_clist
			}{
				xecho -b Server $servname is not on the challenge list
			}
		}

		(-l) (-list)
		{
			if (numitems(oper.challenge))
			{
				xecho -b Challenge list:
				echo Server                     Nick         Key
				for cnt from 1 to $numitems(oper.challenge)
				{
					@ :tmp  = getitem(oper.challenge ${cnt-1})
					@ :serv = word(0 $tmp)
					@ :nick = word(1 $tmp)
					@ :key  = word(2 $tmp)
					echo $[26]serv $[12]nick $key
				}
			}{
				xecho -b There are no entries in the challenge list
			}
		}

		(*)
		{
			@ :nick = [$0]

			if (fexist($CONFIG.CHALLENGE_RSA_RESPOND) == -1)
			{
				xecho -b -s Invalid rsa respond path. Aborting challenge.
				return
			}

			if ((:item = matchitem(oper.challenge $servername() *)) > -1)
			{
				stack push on 386
				^on ^386 "*"
				{
					@ :item = matchitem(oper.challenge $0 *)
					@ :tmp = getitem(oper.challenge $item)
					@ :key = word(2 $tmp)
					@ :resp = pipe($CONFIG.CHALLENGE_RSA_RESPOND $key $1)
					if (resp) {
						quote challenge +$resp
					} else {
						xecho -b -s No response returned. Challenge for $servername() failed.
					}
					stack pop on 386
				}

				quote challenge $0
			}{
				xecho -b -s No entry for $servername() in the challenge list
				xecho -b -s You can add entries with: /CHALLENGE -add <server> <nick> <key>
				xecho -b -s For a manual challenge/response use /QUOTE CHALLENGE
			}
		}
	}
}

alias operview (...)
{
	if ([$0]) {
		dset OPERVIEW $0
	} else {
		dset OPERVIEW ${CONFIG.OPERVIEW ? 0 : 1}
	}
}

alias operwall (text)
{
	if (text) {
		//quote operwall :$text
	} else {
		xecho -b Usage: /OPERWALL <text>
	}
}


/****** INTERNAL ALIASES ******/

alias oper.add_tabcomp (void)
{
	^alias tabkey.cmd.challenge (...)
	{
		bless
		if (curword == 1)
		{
			@ :tmp = [-ADD -DELETE -LIST]
			push tmp $tabkey.method.nick($*)
			@ function_return = pattern("$word*" $tmp)
		}\
		else if (curword == 2)
		{
			^local servernames
			if (match($word(1 $L) -a -add))
			{
				for serv in ($serverrefs())
				{
					if (serv > -1 && (:servname = servername($serv)) != [<none>]) {
						push servernames $servname
					}
				}
			}\
			else if (match($word(1 $L) -d -del -delete))
			{
				for cnt from 1 to $numitems(oper.challenge) {
					push servernames $word(0 $getitem(oper.challenge ${cnt-1}))
				}
			}{
				/* Disable completion */
				@ :servernames = [ ]
			}
			@ function_return = servernames
		}\
		else if (curword == 4)
		{
			@ function_return = tabkey.method.file($*)
		}{
			@ function_return = tabkey.method.nick($*)
		}
	}
}

alias oper.operview.create (void)
{
	if (winnum(operview) == -1)
	{
		window new name operview
		oper.operview.fix
	}
}

alias oper.operview.fix (void)
{
	if (winnum(operview) != -1)
	{
		window operview level $CONFIG.OPERVIEW_LEVEL
		if (CONFIG.OPERVIEW_HIDDEN)
		{
			window operview hide

			if (STATUS.DOUBLE) {
				window operview double on
			}
			if ((:item = matchitem(single_status operview)) > -1) {
				@ delitem(single_status $item)
			}
		}{
			/*
			 * Make sure that the operview window is visible but
			 * never becomes the active window.
			 */
			if (!winvisible(operview)) {
				window show operview
			}

			if (winnam() == [operview])
			{
				^local visible
				for wref in ($winrefs())
				{
					if (winvisible($wref)) {
						push visible $wref
					}
				}

				if (#visible == 1)
				{
					window previous
					window show operview
					window last
				}{
					for wref in ($visible)
					{
						if (!match($winnam($wref) operview msgs))
						{
							window refnum $wref
							break
						}
					}
				}
			}

			window operview double off fixed on size $CONFIG.OPERVIEW_SIZE

			if (finditem(single_status operview) < 0) {
				@ setitem(single_status $numitems(single_status) operview)
			}
		}
	}
}

alias oper.operview.destroy (void)
{
	if (winnum(operview) != -1) {
		window operview kill
	}
	if ((:item = matchitem(single_status operview)) > -1) {
		@ delitem(single_status $item)
	}
}

alias oper.read_clist (file default "$DS.USER_DIR/challenge.sav", void)
{
	if (fexist($file) == 1)
	{
		@ delarray(oper.challenge)
		@ :fd = open($file R)
		while (!eof($fd))
		{
			if ((:line = read($fd))) {
				@ setitem(oper.challenge $numitems(oper.challenge) $line)
			}
		}
		@ close($fd)
	}
}

alias oper.write_clist (file default "$DS.USER_DIR/challenge.sav", void)
{
	@ unlink($file)

	if ((:fd = open($file W)) == -1)
	{
		echo Error: oper.write_clist: Unable to write to $file
		return
	}

	for cnt from 1 to $numitems(oper.challenge)
	{
		@ :item = cnt - 1
		@ write($fd $getitem(oper.challenge $item))
	}

	@ close($fd)
}


/****** ON HOOKS ******/

on #^381 427 "*"
{
	//mode $servernick() $CONFIG.OPER_UMODES
}

on #-connect 427 "*"
{
	if (CONFIG.AUTO_CHALLENGE)
	{
		@ :servname = [$2]
		@ :item = matchitem(oper.challenge $servname *)
		if (item > -1)
		{
			@ :nick = word(1 $getitem(oper.challenge $item))
			xecho -b Sending challenge for $nick to $servname
			xeval -s $servernum() -- challenge $nick
		}
	}
}

on #-hook 427 "CONFIG OPERVIEW *"
{
	if (CONFIG.OPERVIEW) {
		oper.operview.create
	} else {
		oper.operview.destroy
	}
}

on #-hook 427 "CONFIG OPERVIEW_HIDDEN *"
{
	oper.operview.fix
}

on #-hook 427 "CONFIG OPERVIEW_LEVEL *"
{
	@ :bad = :good = []
	@ :levels = [ACTIONS CRAP CTCP DCC MSGS NOTES NOTICES OPNOTES PUBLIC SNOTES USERLOG1 USERLOG2 USERLOG3 USERLOG4 WALLOPS WALLS]
	for lvl in ($split(, $CONFIG.OPERVIEW_LEVEL))
	{
		if (findw($lvl $levels) > -1) {
			push good $lvl
		} else {
			push bad $lvl
		}
	}

	if (bad)
	{
		for lvl in ($bad) {
			xecho -b Unknown level: $toupper($lvl)
		}
		xecho -b Valid levels: $levels
		if (good) {
			@ :newlevels = unsplit(, $good)
		} else {
			@ :newlevels = [$2-]
		}
		^assign CONFIG.OPERVIEW_LEVEL $toupper($newlevels)
		xecho -b Value of OPERVIEW_LEVEL set to $CONFIG.OPERVIEW_LEVEL
	}{
		^assign CONFIG.OPERVIEW_LEVEL $toupper($CONFIG.OPERVIEW_LEVEL)
	}

	if (CONFIG.OPERVIEW) {
		window operview level $CONFIG.OPERVIEW_LEVEL
	}
}

on #-hook 427 "CONFIG OPERVIEW_SIZE *"
{
	@ :size = CONFIG.OPERVIEW_SIZE
	@ :max_size = word(1 $geom()) - 4
	if (!isnumber($size b10) || size < 1 || size > max_size)
	{
		xecho -b Value must be an integer greater than 0 and no larger than $max_size
		^assign CONFIG.OPERVIEW_SIZE $2
		xecho -b Value of OPERVIEW_SIZE set to $CONFIG.OPERVIEW_SIZE
	}
	if (CONFIG.OPERVIEW && !CONFIG.OPERVIEW_HIDDEN) {
		window operview size $CONFIG.OPERVIEW_SIZE
	}
}

on #-hook 427 "LOADMOD tabkey"
{
	oper.add_tabcomp
}

on #-timer 427 "*"
{
	if (CONFIG.AUTO_CHALLENGE)
	{
		for serv in ($serverrefs())
		{
			@ :servname = servername($serv)
			@ :item = matchitem(oper.challenge $servname *)
			if (serv > -1 && item > -1)
			{
				if (!pass(oO $usermode($serv)))
				{
					@ :nick = word(1 $getitem(oper.challenge $item))
					xecho -b Sending challenge for $nick to $servername($serv)
					xeval -s $serv -- challenge $nick
				}
			}
		}
	}
}

on ^wallop "*"
{
	if (FORMAT.WALLOP) {
		echo $fparse(WALLOP $*)
	}
}

on #-window_create 427 "*"
{
	oper.operview.fix
}

on #-window_kill 427 "*"
{
	oper.operview.fix
}

on #-window_kill 427 "operview"
{
    if (CONFIG.OPERVIEW) {
        dset OPERVIEW OFF
    }
}


/****** STARTUP ******/

if (isloaded(tabkey)) {
	oper.add_tabcomp
}

if (CONFIG.OPERVIEW) {
	oper.operview.create
}

oper.read_clist


/* EOF */