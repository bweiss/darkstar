#version 0.3
/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * TABKEY.DSM - Tab key module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 2/17/02 (bmw)
 *
 * This script uses serial number 420 for all /on hooks.
 */

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_connect 420 -"% CHAT *"

	^alias -cleartab

	@ delarray(tabkey_rules)
	@ delarray(tabkey_rinfo)

	^bind ^I toggle_insert_mode
}

config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX :


bind ^I parse_command tabkey.process_tabkey


alias cleartab (void)
{
	for var in ($aliasctl(assign match TABKEY.NICKS.))
	{
		^assign -$var
	}

	for var in ($aliasctl(assign match TABKEY.INDEX.))
	{
		^assign -$var
	}

	xecho -b Tabkey history cleared
}


/*
 * tabkey.addrule <pattern> <procedure> [word list]
 *
 * Adds a new completion rule. Both <pattern> and [word list] MUST be double
 * quoted or things will break. The <procedure> argument should be the member
 * name of an existing tabkey procedure (tabkey.proc.<procedure>).
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule
{
	@ :pattern = word(0 $*)
	^local pattern \"$pattern\"
	@ :proc = word(1 $*)
	@ :list = word(2 $*)

	if (!pattern || !proc)
	{
		xecho -b Error: tabkey.addrule: Not enough arguments
		return
	}

	/*
	 * We check for > 0 here instead of > -1 because rule 0 (pattern: "")
	 * would match rules with patterns like "*", and we don't want that.
	 */
	if (matchitem(tabkey_rules $pattern) > 0)
	{
		xecho -b Error: tabkey.addrule: Pattern $pattern already exists in current rules
		return
	}

	if (aliasctl(alias match tabkey.proc.$proc))
	{
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $proc${list ? [ $list] : []})
	}{
		xecho -b Error: tabkey.addrule: Invalid completion procedure [$proc]
	}
}

/*
 * Adds nicks to the msg_routine history. This will keep separate lists for
 * each server you are connected to.
 */
alias tabkey.addnick (nick, void)
{
	if (match($nick $TABKEY.NICKS[$winserv()]))
	{
		@ TABKEY.NICKS.$winserv() = remw($nick $TABKEY.NICKS[$winserv()])
	}

	if (numwords($TABKEY.NICKS[$winserv()]) == CONFIG[TABKEY_NICK_HISTORY])
	{
		shift TABKEY.NICKS.$winserv()
	}

	@ push(TABKEY.NICKS[$winserv()] $nick)
	@ TABKEY.INDEX.$winserv() = [-1]
}

/*
 * Generic completion procedure. This can be used by the other procedures that
 * will be called by tabkey.process_tabkey or as an example for writing your
 * own. If you would like the completed word to be suffixed with something
 * other than a space, you can change the value of TABKEY.SUFFIX in your
 * procedure.
 */
alias tabkey.complete (word, list)
{
	if (!word || !list)
	{
		return
	}

	if (word == [*])
	{
		@ :matches = list
	}{
		@ :matches = pattern($word% $list)
	}

	if (#matches == 1)
	{
		^assign -TABKEY.SHOWMATCHES
		parsekey delete_to_previous_space
		xtype -l $matches$TABKEY.SUFFIX
	}\
	else if (#matches > 1)
	{
		beep
		@ TABKEY.SHOWMATCHES++
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)

		if (TABKEY[SHOWMATCHES] > 1)
		{
			xecho -b Matches:
			for tmp in ($matches)
			{
				echo $tmp
			}
		}
	}{
		^assign -TABKEY.SHOWMATCHES
	}
}

alias tabkey.display_rules (void)
{
	echo #   Pattern                      Routine    Word List
	for cnt from 0 to ${numitems(tabkey_rules) - 1}
	{
		@ :pattern = getitem(tabkey_rules $cnt)
		@ :routine = word(0 $getitem(tabkey_rinfo $cnt))
		@ :list = restw(1 $getitem(tabkey_rinfo $cnt))
		@ :num = cnt + 1
		echo $[3]num $[28]pattern $[10]routine ${list ? list : []}
	}
}

/*
 * This is called whenever the user actually pushes the Tab key.
 */
alias tabkey.process_tabkey (void)
{
	@ :item = rmatchitem(tabkey_rules "$L")

	if (item > -1)
	{
		@ :rinfo = getitem(tabkey_rinfo $item)
		@ :proc = word(0 $rinfo)
		eval ^local list $restw(1 $rinfo)
		@ TABKEY.SUFFIX = [ ]
		tabkey.proc.$proc $list
	}
}

	
/*
 * COMPLETION PROCEDURES
 * These will be called by tabkey.process_tabkey when a matching completion
 * rule is found. Where possible, they should use tabkey.complete to do
 * most of the work.
 */

alias tabkey.proc.channel (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		tabkey.complete * $list
	}{
		@ :lastw = word(${#L - 1} $L)
		@ :lastw = sar(g/\\/\\\\\/$lastw)
		tabkey.complete $lastw $list
	}
}

alias tabkey.proc.command (void)
{
	parsekey command_completion
}

alias tabkey.proc.file (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@ :lastw = twiddle($word(${#L - 1} $L))
		@ :matches = pattern($lastw% $glob($lastw*))
		
		if (#matches == 1)
		{
			^assign -TABKEY.SHOWMATCHES
			@ :lastc = mid(${strlen($matches) - 1} 1 $matches)
			parsekey delete_to_previous_space
			xtype -l $matches${lastc == [/] ? [] : [ ]}
		}\
		else if (#matches > 1)
		{
			beep
			@ TABKEY.SHOWMATCHES++
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)

			if (TABKEY[SHOWMATCHES] > 1)
			{
				xecho -b Matches:
				for file in ($matches)
				{
					echo $file
				}
			}
		}{
			^assign -TABKEY.SHOWMATCHES
		}
	}
}

alias tabkey.proc.lmods (void)
{
	^local modules
	for cnt from 0 to ${numitems(loaded_modules) - 1}
	{
		@ push(modules $getitem(loaded_modules $cnt))
	}

	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		tabkey.complete * $modules
	}{
		@ :lastw = word(${#L - 1} $L)
		tabkey.complete $lastw $modules
	}
}

alias tabkey.proc.mods (void)
{
	^local modules
	for cnt from 0 to ${numitems(modules) - 1}
	{
		@ push(modules $getitem(modules $cnt))
	}

	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		tabkey.complete * $modules
	}{
		@ :lastw = word(${#L - 1} $L)
		tabkey.complete $lastw $modules
	}
}

alias tabkey.proc.msg (void)
{
	@ :nicks = TABKEY.NICKS[$winserv()]
	@ :index = TABKEY.INDEX[$winserv()]
	@ :msg_cmd = CMDCHARS ## [msg]
	@ :trailing = restw(2 $L)

	if (nicks)
	{
		if (index > 0)
		{
			@ :nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		}{
			@ :nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}

		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	}{
		@ TABKEY.INDEX.$winserv() = [-1]
	}
}

alias tabkey.proc.nick (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		tabkey.complete * $list
	}{
		@ :lastw = word(${#L - 1} $L)
		@ :lastw = sar(g/\\/\\\\\/$lastw)
		if (#L < 2)
		{
			@ TABKEY.SUFFIX = CONFIG[TABKEY_NICKCOMP_SUFFIX] ## [ ]
		}
		tabkey.complete $lastw $list
	}
}

alias tabkey.proc.config (void)
{
	tabkey.set_routine config
}

alias tabkey.proc.format (void)
{
	tabkey.set_proc format
}

alias tabkey.set_proc (type, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		if (left(1 $word(1 $L)) == [-])
		{
			@ :rmflag = 1
			@ :word1 = strip(- $word(1 $L))
		}{
			@ :word1 = word(1 $L)
		}
		
		@ :matches = aliasctl(assign match $type\.$word1)
		^local new_matches
		for var in ($matches)
		{
			@ push(new_matches $after(1 . $var))
		}
		
		if (#new_matches == 1)
		{
			^assign -TABKEY.SHOWMATCHES
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$new_matches${[ ]}
		}\
		else if (#new_matches > 1)
		{
			beep
			@ TABKEY.SHOWMATCHES++
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$prefix($newvars)

			if (TABKEY[SHOWMATCHES] > 1)
			{
				xecho -b Matches:
				for var in ($newvars)
				{
					echo $var
				}
			}
		}{
			^assign -TABKEY.SHOWMATCHES
		}
	}
}


/*
 * Add the nicks of people you are chatting with to the msg history.
 */
for hook in (msg send_msg)
{ 
	on #^$hook 420 "*"
	{
		@ tabkey.addnick $0
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*"
	{
		@ tabkey.addnick =$0
	}
}

on #^dcc_connect 420 "% CHAT *"
{
	@ tabkey.addnick =$0
}


/*
 * DEFAULT COMPLETION RULES
 * I will add a user interface to add/remove these in the near future.
 *
 * We have to add rule 0 manually because $word() sees "" as a missing
 * argument and fails. This rule is also exempt from tabkey.addrule's
 * duplicate rule check since $matchitem() matches "" and "*".
 */
@ setitem(tabkey_rules 0 "")
@ setitem(tabkey_rinfo 0 msg !DO NOT REMOVE!)

tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "*#%"                channel     "$mychannels()"
tabkey.addrule "/%"                 command
tabkey.addrule "/config %"          config
tabkey.addrule "/dset %"            config
tabkey.addrule "/format %"          format
tabkey.addrule "/fset %"            format
tabkey.addrule "/loadmod *"         mods
tabkey.addrule "/reloadmod *"       lmods
tabkey.addrule "/save *"            lmods
tabkey.addrule "/unloadmod *"       lmods
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel     "$mychannels()"
tabkey.addrule "/join *"            channel     "$mychannels()"
tabkey.addrule "/j *"               channel     "$mychannels()"
tabkey.addrule "/leave *"           channel     "$mychannels()"
tabkey.addrule "/part *"            channel     "$mychannels()"
tabkey.addrule "/mode %"            channel     "$mychannels()"


/* bmw '01 */