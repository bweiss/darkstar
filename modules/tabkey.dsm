#version 0.7.3
/* $Id$ */
/*
 * tabkey.dsm - Tab key module for DarkStar/EPIC4
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 420 for all /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_request 420 -"% CHAT *"
	^on #send_ctcp 420 -"PRIVMSG % DCC CHAT *"
	^alias -tabkey
	^bind ^I toggle_insert_mode
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX ,


/****** INIT ******/

/*
 * Add a module info line for display with /dinfo.
 */
assign MODINFO.TABKEY.1 Completion rules: $numitems(tabkey.rules)

/*
 * Call tabkey.process_tabkey whenever the Tab key is pressed.
 */
bind ^I parse_command tabkey.process_tabkey


/****** USER ALIASES ******/

alias tabkey
{
	switch ($tolower($0))
	{
		(addrule)   {tabkey.addrule $1-}
		(clear) {
			purge TABKEY.NICKS
			purge TABKEY.INDEX
			xecho -b Tabkey history cleared
		}
		(listrules) {tabkey.listrules}
		(rmrule)    {tabkey.rmrule $1-}
		(saverules) {tabkey.saverules}
		(*) {
			xecho -b Invalid sub-command: $0
			xecho -b Usage: /tabkey <sub-command> [arguments]
			xecho -b   - <sub-command> and [arguments] can be any one of the following.
			xecho -b        addrule <pattern> <procedure> [extra arguments]
			xecho -b        clear
			xecho -b        listrules
			xecho -b        rmrule <pattern>
			xecho -b        saverules
			xecho -b   - In all cases, <pattern> and [extra arguments] must be quoted
			xecho -b See ds:tabkey(3) for details
		}
	}
}


/****** INTERNAL ALIASES ******/

/*
 * tabkey.addrule <pattern> <procedure> [extra arguments]
 *
 * Adds a new completion rule. Both <pattern> and [extra arguments] MUST
 * be double quoted or things will break. It is also important to be aware
 * that [extra arguments] will be evaluated just before the completion
 * takes place. The <procedure> argument should be the member name of an
 * existing tabkey procedure (tabkey.proc.<procedure>) and [extra arguments]
 * is given as the arguments to the procedure being executed.
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule
{
	@:pattern = word(0 $*)
	/* This is here to deal with a pattern of "" */
	if (!pattern) {
		@:proc = word(0 $restw(1 $*))
		@:extra = restw(1 $restw(1 $*))
	} else {
		@:proc = word(1 $*)
		@:extra = word(2 $*)
	}
	@:pattern = ["] ## pattern ## ["]

	if (!proc) {
		xecho -b Error: tabkey.addrule: Not enough arguments
		return
	}

	@:foo = finditem(tabkey.rules $pattern)
	if (foo > -1) {
		xecho -b Error: tabkey.addrule: Pattern $pattern already exists in current rules \(${foo+1}\)
		return
	}

	if (aliasctl(alias match tabkey.proc.$proc)) {
		@ setitem(tabkey.rules $numitems(tabkey.rules) $pattern)
		@ setitem(tabkey.rinfo $numitems(tabkey.rinfo) $proc${extra ? [ $extra] : []})
		xecho -s -b Added completion rule #$numitems(tabkey.rules): $pattern \($proc\)
	} else {
		xecho -b Error: tabkey.addrule: Invalid completion procedure [$proc]
	}
}

/*
 * Adds <nick> to the msg history for <server>.
 */
alias tabkey.addnick (server, nick, void)
{
	if (server == [] || !nick) {
		xecho -b Error: tabkey.addnick: Not enough arguments
		return
	}

	if (match($nick $TABKEY.NICKS[$server])) {
		@ TABKEY.NICKS.$server = remw($nick $TABKEY.NICKS[$server])
	}

	if (numwords($TABKEY.NICKS[$server]) == CONFIG.TABKEY_NICK_HISTORY) {
		shift TABKEY.NICKS.$server
	}

	@ push(TABKEY.NICKS[$server] $nick)
	@ TABKEY.INDEX.$server = [-1]
}

alias tabkey.listrules (void)
{
	echo #   Pattern                    Procedure    Extra Arguments
	for cnt from 0 to ${numitems(tabkey.rules) - 1} {
		@:pattern = getitem(tabkey.rules $cnt)
		@:proc = word(0 $getitem(tabkey.rinfo $cnt))
		@:extra = restw(1 $getitem(tabkey.rinfo $cnt))
		@:num = cnt + 1
		echo $[3]num $[26]pattern $[12]proc ${extra ? ["$extra"] : []}
	}
}

/*
 * This is called whenever the user actually pushes the Tab key.
 */
alias tabkey.process_tabkey (void)
{
	@:item = rmatchitem(tabkey.rules "$L")
	if (item > -1) {
		@:rinfo = getitem(tabkey.rinfo $item)
		@:proc = word(0 $rinfo)
		eval ^local extra $restw(1 $rinfo)
		tabkey.proc.$proc $extra
		@ TABKEY.LAST_INPUT = L
	}
}

/*
 * Removes a rule that matches <pattern>. Just like everywhere else, the
 * pattern should be encased in double quotes. If <pattern> is "all" then
 * all completion rules will be removed.
 */
alias tabkey.rmrule (pattern)
{
	if (tolower($pattern) == [all]) {
		@ delarray(tabkey.rules)
		@ delarray(tabkey.rinfo)
		xecho -s -b Removed all completion rules
		return
	}

	@:item = finditem(tabkey.rules $pattern)
	if (item > 0) {
		@ delitem(tabkey.rules $item)
		@ delitem(tabkey.rinfo $item)
		xecho -s -b Removed completion rule #${item + 1}: $pattern
	} else {
		xecho -b Error: tabkey.rmrule: No rules matching $pattern were found
	}
}

/*
 * Saves all completion rules to $DS.SAVE_DIR/tabkey.rules
 */
alias tabkey.saverules (void)
{
	if (!numitems(tabkey.rules)) {
		xecho -b Error: tabkey.saverules: No completion rules found
		return
	}

	@:file = DS.SAVE_DIR ## [/tabkey.rules]
	@ unlink($file)
	@:fd = open($file W)

	if (fd == -1) {
		xecho -b Error: tabkey.saverules: Unable to open $file for writing
		return
	}

	for cnt from 0 to ${numitems(tabkey.rules) - 1}
	{
		@:pattern = getitem(tabkey.rules $cnt)
		@:proc = word(0 $getitem(tabkey.rinfo $cnt))
		@:extra = restw(1 $getitem(tabkey.rinfo $cnt))
		@:cmd = [tabkey.addrule ] ## getitem(tabkey.rules $cnt) ## [ ] ## proc
		if (extra) {
			@:cmd = cmd ## [ "] ## extra ## ["]
		}
		@ write($fd $cmd)
	}

	@ close($fd)
	xecho -b Saved $numitems(tabkey.rules) completion rules to $file
}

/*
 * Beeps the terminal and displays the <list> of matches when the tabkey is
 * pressed a second time. This is intended to be used by the completion
 * procedures since almost all of them want it.
 */
alias tabkey.show_matches (list)
{
	if (!list) {
		return
	}

	beep

	if (L == TABKEY.LAST_INPUT && strlen($L) == strlen($TABKEY.LAST_INPUT)) {
		xecho -b Matches:
		for tmp in ($list) {
			echo $tmp
		}
	}
}

	
/*
 * COMPLETION PROCEDURES
 * These will be called by tabkey.process_tabkey when a matching completion
 * rule is found. In order to be recognized as a valid completion procedure
 * (in rules) they must be in the tabkey.proc structure. Anything not in this
 * structure is being called by something that is.
 */

alias tabkey.proc.aliasctl (type, void)
{
	if (!type) {
		return
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@:lastw = word(${#L - 1} $L)

		/* Deal with the removal of variables correctly. */
		if (left(1 $lastw) == [-]) {
			@:rm = 1
			@:lastw = mid(1 $strlen($lastw) $lastw)
		}

		@:matches = pattern($lastw% $aliasctl($type match $lastw))

		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.array (array, void)
{
	^local items
	for cnt from 0 to ${numitems($array) - 1} {
 		@ push(items $getitem($array $cnt))
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = items
	} else {
		@:lastw = word(${#L - 1} $L)
		@:matches = pattern($lastw% $items)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.channel (list default "$mychannels()")
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = list
	} else {
		@:lastw = word(${#L - 1} $L)
		/* This allows us to complete channels with "\" in them. */
		@:lastw = sar(g/\\/\\\\\/$lastw)
		@:matches = pattern($lastw% $list)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.command (void)
{
	if (numwords($L) == 1)
	{
		parsekey command_completion
	}{
		@:lastw = word(${#L - 1} $L)
		@:matches = getcommands($lastw%)
		if (!matches) {
			@:matches = aliasctl(alias match $lastw)
		}

		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l $matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.file (void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ]) {
		@:lastw = twiddle($word(${#L - 1} $L))
		@:matches = pattern($lastw% $glob($lastw*))
		if (#matches == 1) {
			@:lastc = mid(${strlen($matches) - 1} 1 $matches)
			parsekey delete_to_previous_space
			xtype -l $matches${lastc == [/] ? [] : [ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.generic (list)
{
	if (!list) {
		return
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ]) {
		@:lastw = word(${#L - 1} $L)
		@:matches = pattern($lastw% $list)
		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l $matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

/*
 * This attempts to turn the last word on the input prompt into a
 * hostmask suitable for use with commands like /ignore and /ban.
 * Currently, it uses a mask type of 3 (see mask(6) in the EPIC help
 * files) but I may make this configurable at some later date.
 */
alias tabkey.proc.mask (void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ]) {
		@:lastw = twiddle($word(${#L - 1} $L))
		/* Try getting their userhost from cache first. */
		@:uhost = userhost($lastw)
		/* If that fails, query the server via $uh(). */
		if (uhost == [<UNKNOWN>@<UNKNOWN>]) {
			@:uhost = uh($lastw)
		}
		/* If both fail, the user is not online and we should give up. */
		if (uhost == [<UNKNOWN>@<UNKNOWN>]) {
			return
		}

		parsekey delete_to_previous_space
		xtype -l $mask(3 $uhost)${[ ]}
	}
}

alias tabkey.proc.msg (void)
{
	@:nicks = TABKEY.NICKS[$winserv()]
	@:index = TABKEY.INDEX[$winserv()]
	@:msg_cmd = CMDCHARS ## [msg]
	@:trailing = restw(2 $L)

	if (nicks) {
		if (index > 0) {
			@:nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		} else {
			@:nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}
		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	} else {
		@ TABKEY.INDEX.$winserv() = [-1]
	}
}

alias tabkey.proc.nick (list)
{
	if (!list) {
		@:list = onchannel()
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = list
	} else {
		@:lastw = word(${#L - 1} $L)
		/* This allows us to complete nicks with "\" in them. */
		@:lastw = sar(g/\\/\\\\\/$lastw)
		if (#L < 2) {
			@:suffix = CONFIG.TABKEY_NICKCOMP_SUFFIX ## [ ]
		} else {
			@:suffix = [ ]
		}
		@:matches = pattern($lastw% $list)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches$suffix
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.set (type, void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@:lastw = word(${#L - 1} $L)

		/* Deal with the removal of variables correctly. */
		if (left(1 $lastw) == [-]) {
			@:rm = 1
			@:lastw = mid(1 $strlen($lastw) $lastw)
		}
		
		switch ($tolower($type))
		{
			(set) {
				@:matches = getsets($lastw%)
			}
			(config) (format) {
				^local matches
				for var in ($aliasctl(assign match $type\.$lastw)) {
					push matches $after(1 . $var)
				}
			}
		}
		
		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}


/****** ON HOOKS ******/

/*
 * Add the nicks of people you are chatting with to the msg history.
 */
for hook in (msg send_msg)
{
	on #^$hook 420 "*" {
		tabkey.addnick $servernum() $0
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*" {
		for sref in ($serverrefs()) {
			tabkey.addnick $sref =$0
		}
	}
}

on #^dcc_request 420 "% CHAT *"
{
	for sref in ($serverrefs()) {
		tabkey.addnick $sref =$0
	}
}

on #^send_ctcp 420 "PRIVMSG % DCC CHAT *"
{
	for sref in ($serverrefs()) {
		tabkey.addnick $sref =$1
	}
}


/****** STARTUP ******/

/*
 * DEFAULT COMPLETION RULES
 *
 * These should not be edited directly. If you wish to setup custom rules
 * you should use the /tabkey alias to create and then save your rule set.
 *
 * Warning: Currently spaces are ignored here but tabs are not. If you use
 * tabs for readability your completion procedure will be rejected.
 */
tabkey.addrule ""                   msg
tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "#%"                 channel
tabkey.addrule "* #%"               channel
tabkey.addrule "/%"                 command
tabkey.addrule "/do %"              command
tabkey.addrule "/eval %"            command
tabkey.addrule "/tabkey %"          generic     "addrule clear listrules rmrule saverules"
tabkey.addrule "/config %"          set         "config"
tabkey.addrule "/dset %"            set         "config"
tabkey.addrule "/format %"          set         "format"
tabkey.addrule "/fset %"            set         "format"
tabkey.addrule "/set %"             set         "set"
tabkey.addrule "/loadmod *"         array       "modules"
tabkey.addrule "/reloadmod *"       array       "loaded_modules"
tabkey.addrule "/save *"            array       "loaded_modules"
tabkey.addrule "/status %"          array       "status"
tabkey.addrule "/theme %"           array       "themes"
tabkey.addrule "/unloadmod *"       array       "loaded_modules"
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel
tabkey.addrule "/join *"            channel
tabkey.addrule "/j *"               channel
tabkey.addrule "/leave *"           channel
tabkey.addrule "/part *"            channel
tabkey.addrule "/mode %"            channel
tabkey.addrule "/m #%"              channel
tabkey.addrule "/msg #%"            channel
tabkey.addrule "/assign %"          aliasctl    "assign"
tabkey.addrule "/push %"            aliasctl    "assign"
tabkey.addrule "/pop %"             aliasctl    "assign"
tabkey.addrule "/shift %"           aliasctl    "assign"
tabkey.addrule "/unshift %"         aliasctl    "assign"
tabkey.addrule "/foreach %"         aliasctl    "assign"
tabkey.addrule "/foreach -%"        aliasctl    "alias"
tabkey.addrule "/alias %"           aliasctl    "alias"
tabkey.addrule "/ban *"             mask
tabkey.addrule "/ignore %"          mask
tabkey.addrule "/ignore % *"        generic     "ALL CRAP CTCPS INVITES JOINS MSGS NICKS NONE NOTES NOTICES PARTS PUBLIC TOPICS WALLS WALLOPS"

/*
 * Load the user's custom rule set if one exists.
 */
if (fexist($DS.SAVE_DIR/tabkey.rules) == 1) {
	^tabkey.rmrule all
	^load $DS.SAVE_DIR/tabkey.rules
}


/* EOF */