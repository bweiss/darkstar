/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * TABKEY.DSM - Tab key module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 10/21/01 (bmw)
 *
 * This script uses serial number 420 for all ON hooks.
 */

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_connect 420 -"% CHAT *"

	^cleartab
	^alias -cleartab

	^bind ^I toggle_insert_mode
}


bind ^I parse_command tabkey.process_tabkey


alias cleartab (void)
{
	xecho -s -b Clearing tabkey history...

	for var in ($aliasctl(assign match TABKEY.NICKS.))
	{
		^assign -$var
	}

	for var in ($aliasctl(assign match TABKEY.INDEX.))
	{
		^assign -$var
	}
}


alias tabkey.process_tabkey (void)
{
	if (L)
	{
		/* Check for $CMDCHARS */
		if (index($left(1 $L) $K) > -1)
		{
			switch ($rest(1 $L))
			{
				(%)
				{
					parsekey command_completion
				}

				(channel %) (j %) (join %) (l %) (leave %) (mode %) (part %)
				{
					@ tabkey.channel_routine()
				}			

				(dcc send % %) (exec *) (less %) (load %)
				{
					@ tabkey.file_routine()
				}

				(loadmod %)
				{
					@ tabkey.module_routine(modules)
				}

				(reloadmod %) (save *) (unloadmod %)
				{
					@ tabkey.module_routine(loaded_modules)
				}

				(m % *) (msg % *)
				{
					@ tabkey.msg_routine()
				}

				(config %) (dset %)
				{
					@ tabkey.set_routine(CONFIG)
				}

				(fset %)
				{
					@ tabkey.set_routine(FORMAT)
				}

				(*)
				{
					@ tabkey.nick_routine()
				}
			}
		}{
			@ tabkey.nick_routine()
		}
	}{
		@ tabkey.msg_routine()
	}
}	
	
alias tabkey.add_nick (nick, void)
{
	if (match($nick $TABKEY.NICKS[$winserv()]))
	{
		@ TABKEY.NICKS.$winserv() = remw($nick $TABKEY.NICKS[$winserv()])
	}

	if (numwords($TABKEY.NICKS[$winserv()]) == CONFIG[TABKEY_NICK_HISTORY])
	{
		shift TABKEY.NICKS.$winserv()
	}

	@ push(TABKEY.NICKS[$winserv()] $nick)
	@ TABKEY.INDEX.$winserv() = [-1]

	return
}

alias tabkey.channel_routine (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		@ :lastw = word(${#L - 1} $L)
		@ :findchan = pattern($lastw% $mychannels())
		
		if (match($lastw $findchan))
		{
			xecho -b Matches:
			echo $findchan
		}
		
		if (#findchan == 1)
		{
			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l $findchan$space
		} \
		elsif (#findchan > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findchan)
			
			@ :lastw = word(${#L - 1} $L)
			
			if (!match($lastw $findchan))
			{
				xecho -b Matches:
				echo $findchan
			}
		}
	}
	
	return
}

alias tabkey.file_routine (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)

	unless (lastc == [ ])
	{
		@ :lastw = twiddle($word(${#L - 1} $L))
		@ :findfile = pattern($lastw% $glob($lastw*))
		
		if (#findfile == 1)
		{
			@ :lastc = mid(${strlen($findfile) - 1} 1 $findfile)
 			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l $findfile${lastc == [/] ? [] : [ ]}
		} \
		elsif (#findfile > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findfile)

			xecho -b Matches:
			for file in ($findfile)
			{
				echo $file
			}
		}
	}
	
	return
}

alias tabkey.module_routine (array, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		^local modules
		
		for cnt from 1 to $numitems($array)
		{
			@ :itm = cnt - 1
			@ push(modules $getitem($array $itm))
		}
		
		@ :lastw = word(${#L - 1} $L)
		@ :findmod = pattern($lastw% $modules)

		if (match($word(1 $L) $findmod))
		{
			xecho -b Matches:
			echo $findmod
		}
		
		if (#findmod == 1)
		{
			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l $findmod$space
		} \
		elsif (#findmod > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findmod)

			if (!match($word(1 $L) $findmod))
			{
				xecho -b Matches:
				echo $findmod
			}
		}
	}

	return
}

alias tabkey.msg_routine (void)
{
	@ :nicks = TABKEY.NICKS[$winserv()]
	@ :index = TABKEY.INDEX[$winserv()]
	@ :msg_cmd = CMDCHARS ## [msg]
	@ :trailing = restw(2 $L)

	if (nicks)
	{
		^local nick

		if (index > 0)
		{
			@ nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		}{
			@ nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}

		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	}{
		@ TABKEY.INDEX.$winserv() = [-1]
	}

	return
}

alias tabkey.nick_routine (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		@ :lastw = word(${#L - 1} $L)
		@ :findnick = pattern($lastw% $onchannel())
		
		if (match($word(1 $L) $findnick))
		{
			xecho -b Matches:
			echo $findnick
		}
		
		if (#findnick == 1)
		{
			^local space

			if (#L == 1)
			{
				@ space = CONFIG[TABKEY_NICKCOMP_SUFFIX] ## [ ]
			}{
				@ space = [ ]
			}
		
			parsekey delete_to_previous_space
			xtype -l $findnick$space
		} \
		elsif (#findnick > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findnick)

			if (!match($word(1 $L) $findnick))
			{
				xecho -b Matches:
				echo $findnick
			}
		}
	}

	return
}

alias tabkey.set_routine (type, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		^local newvars,rmflag,word1
		
		if (left(1 $word(1 $L)) == [-])
		{
			^assign rmflag 1
			@ word1 = strip(- $word(1 $L))
		}{
			@ word1 = word(1 $L)
		}
		
		@ :cur_value = aliasctl(assign get $type\.$word1)
		@ :findvar = aliasctl(assign match $type\.$word1)
		
		for var in ($findvar)
		{
			@ push(newvars $after(1 . $var))
		}
		
		if (cur_value)
		{
			xecho -b Matches:
			echo $newvars
		}
		
		if (#newvars == 1)
		{
			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$newvars$space
		} \
		elsif (#newvars > 1)
		{
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$prefix($newvars)

			@ :cur_value = aliasctl(assign get $type\.$word(1 $L))

			if (!cur_value)
			{
				xecho -b Matches:
				for var in ($newvars)
				{
					echo $var
				}
			}
		}
	}
	
	return
}

for hook in (msg send_msg)
{ 
	on #^$hook 420 "*"
	{
		@ tabkey.add_nick($0)
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*"
	{
		@ tabkey.add_nick(=$0)
	}
}

on #^dcc_connect 420 "% CHAT *"
{
	@ tabkey.add_nick(=$0)
}


/* bmw '01 */