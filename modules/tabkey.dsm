#version 0.6.10
/* $Id$ */
/*
 * tabkey.dsm - Tab key module for DarkStar/EPIC4
 *
 * Written by Brian Weiss
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 420 for all /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_request 420 -"% CHAT *"
	^on #send_ctcp 420 -"PRIVMSG % DCC CHAT *"
	^alias -cleartab
	^bind ^I toggle_insert_mode
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX , 


/****** INIT ******/

/*
 * Add a module info line for display with /dinfo.
 */
assign MODINFO.TABKEY.1 Completion rules: $numitems(tabkey.rules)

/*
 * Call tabkey.process_tabkey whenever the Tab key is pressed.
 */
bind ^I parse_command tabkey.process_tabkey


/****** USER ALIASES ******/

alias cleartab (void)
{
	purge TABKEY.NICKS
	purge TABKEY.INDEX
	xecho -b Tabkey history cleared
}


/****** INTERNAL ALIASES ******/

/*
 * tabkey.addrule <pattern> <procedure> [word list]
 *
 * Adds a new completion rule. Both <pattern> and [word list] MUST be double
 * quoted or things will break. The <procedure> argument should be the member
 * name of an existing tabkey procedure (tabkey.proc.<procedure>).
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule
{
	@:pattern = word(0 $*)
	@:pattern = ["] ## pattern ## ["]
	@:proc = word(1 $*)
	@:list = word(2 $*)

	if (!pattern || !proc) {
		xecho -b Error: tabkey.addrule: Not enough arguments
		return
	}

	/*
	 * We check for > 0 here instead of > -1 because rule 0 (pattern: "")
	 * would match rules with patterns like "*", and we don't want that.
	 */
	if (matchitem(tabkey.rules $pattern) > 0) {
		xecho -b Error: tabkey.addrule: Pattern $pattern already exists in current rules
		return
	}

	if (aliasctl(alias match tabkey.proc.$proc)) {
		@ setitem(tabkey.rules $numitems(tabkey.rules) $pattern)
		@ setitem(tabkey.rinfo $numitems(tabkey.rinfo) $proc${list ? [ $list] : []})
	} else {
		xecho -b Error: tabkey.addrule: Invalid completion procedure [$proc]
	}
}

/*
 * tabkey.addnick <server refnum> <nick>
 *
 * Adds <nick> to the msg history for <server refnum>. This will keep
 * separate lists for each server you are connected to.
 */
alias tabkey.addnick (server, nick, void)
{
	if (server == [] || !nick) {
		xecho -b Error: tabkey.addnick: Not enough arguments
		return
	}

	if (match($nick $TABKEY.NICKS[$server])) {
		@ TABKEY.NICKS.$server = remw($nick $TABKEY.NICKS[$server])
	}

	if (numwords($TABKEY.NICKS[$server]) == CONFIG.TABKEY_NICK_HISTORY) {
		shift TABKEY.NICKS.$server
	}

	@ push(TABKEY.NICKS[$server] $nick)
	@ TABKEY.INDEX.$server = [-1]
}

alias tabkey.display_rules (void)
{
	echo #   Pattern                    Procedure    Word List
	for cnt from 0 to ${numitems(tabkey.rules) - 1} {
		@:pattern = getitem(tabkey.rules $cnt)
		@:proc = word(0 $getitem(tabkey.rinfo $cnt))
		@:list = restw(1 $getitem(tabkey.rinfo $cnt))
		@:num = cnt + 1
		echo $[3]num $[26]pattern $[12]proc ${list ? list : []}
	}
}

/*
 * Removes a rule that matches <pattern>. Just like everywhere else, the
 * pattern should be encased in double quotes.
 */
alias tabkey.rmrule (pattern)
{
	@:item = matchitem(tabkey.rules $pattern)
	if (item > 0) {
		@ delitem(tabkey.rules $item)
		@ delitem(tabkey.rinfo $item)
	}
}

/*
 * Beeps the terminal and displays the <list> of matches when the tabkey is
 * pressed a second time. This is intended to be used by the completion
 * procedures since almost all of them want it.
 */
alias tabkey.show_matches (list)
{
	if (!list) {
		return
	}

	beep

	if (L == TABKEY.LAST_INPUT && strlen($L) == strlen($TABKEY.LAST_INPUT)) {
		xecho -b Matches:
		for tmp in ($list) {
			echo $tmp
		}
	}
}

/*
 * This is called whenever the user actually pushes the Tab key.
 */
alias tabkey.process_tabkey (void)
{
	@:item = rmatchitem(tabkey.rules "$L")
	if (item > -1) {
		@:rinfo = getitem(tabkey.rinfo $item)
		@:proc = word(0 $rinfo)
		eval ^local list $restw(1 $rinfo)
		tabkey.proc.$proc $list
		@ TABKEY.LAST_INPUT = L
	}
}

	
/*
 * COMPLETION PROCEDURES
 * These will be called by tabkey.process_tabkey when a matching completion
 * rule is found. In order to be recognized as a valid completion procedure
 * (in rules) they must be in the tabkey.proc structure. Anything not in this
 * structure is being called by something that is.
 */

alias tabkey.array_proc (array, void)
{
	^local items
	for cnt from 0 to ${numitems($array) - 1} {
		@ push(items $getitem($array $cnt))
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = items
	} else {
		@:lastw = word(${#L - 1} $L)
		@:matches = pattern($lastw% $items)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.assign (void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@:lastw = word(${#L - 1} $L)

		/* Deal with the removal of variables correctly. */
		if (left(1 $lastw) == [-]) {
			@:rm = 1
			@:lastw = mid(1 $strlen($lastw) $lastw)
		}

		@:matches = pattern($lastw% $aliasctl(assign match $lastw))

		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.channel (list)
{
	if (!list) {
		@:list = mychannels()
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = list
	} else {
		@:lastw = word(${#L - 1} $L)
		/* This allows us to complete channels with "\" in them. */
		@:lastw = sar(g/\\/\\\\\/$lastw)
		@:matches = pattern($lastw% $list)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.command (void)
{
	if (strlen($L) == 1)
	{
		parsekey command_completion
	}{
		@:matches = getcommands($rest(1 $L)%)
		if (!matches) {
			@:matches = aliasctl(alias match $rest(1 $L))
		}

		if (#matches == 1) {
			parsekey erase_line
			xtype -l /$matches${[ ]}
		} else if (#matches > 1) {
			parsekey erase_line
			xtype -l /$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.file (void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ]) {
		@:lastw = twiddle($word(${#L - 1} $L))
		@:matches = pattern($lastw% $glob($lastw*))
		if (#matches == 1) {
			@:lastc = mid(${strlen($matches) - 1} 1 $matches)
			parsekey delete_to_previous_space
			xtype -l $matches${lastc == [/] ? [] : [ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.generic (list)
{
	if (!list) {
		return
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ]) {
		@:lastw = word(${#L - 1} $L)
		@:matches = pattern($lastw% $list)
		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l $matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.lmods (void) {tabkey.array_proc loaded_modules}
alias tabkey.proc.mods  (void) {tabkey.array_proc modules}

alias tabkey.proc.msg (void)
{
	@:nicks = TABKEY.NICKS[$winserv()]
	@:index = TABKEY.INDEX[$winserv()]
	@:msg_cmd = CMDCHARS ## [msg]
	@:trailing = restw(2 $L)

	if (nicks) {
		if (index > 0) {
			@:nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		} else {
			@:nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}
		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	} else {
		@ TABKEY.INDEX.$winserv() = [-1]
	}
}

alias tabkey.proc.nick (list)
{
	if (!list) {
		@:list = onchannel()
	}

	@:lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ]) {
		@:matches = list
	} else {
		@:lastw = word(${#L - 1} $L)
		/* This allows us to complete nicks with "\" in them. */
		@:lastw = sar(g/\\/\\\\\/$lastw)
		if (#L < 2) {
			@:suffix = CONFIG.TABKEY_NICKCOMP_SUFFIX
		}
		@:matches = pattern($lastw% $list)
	}

	if (#matches == 1) {
		parsekey delete_to_previous_space
		xtype -l $matches$suffix
	} else if (#matches > 1) {
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.config (void)	{tabkey.set_proc config}
alias tabkey.proc.format (void)	{tabkey.set_proc format}
alias tabkey.proc.set    (void) {tabkey.set_proc set}

alias tabkey.set_proc (type, void)
{
	@:lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@:lastw = word(${#L - 1} $L)

		/* Deal with the removal of variables correctly. */
		if (left(1 $lastw) == [-]) {
			@:rm = 1
			@:lastw = mid(1 $strlen($lastw) $lastw)
		}
		
		if (tolower($type) == [set]) {
			@:matches = getsets($lastw%)
		} else {
			^local matches
			for var in ($aliasctl(assign match $type\.$lastw)) {
				push matches $after(1 . $var)
			}
		}
		
		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.theme (void)
{
	tabkey.array_proc themes
}


/****** ON HOOKS ******/

/*
 * Add the nicks of people you are chatting with to the msg history.
 */
for hook in (msg send_msg)
{
	on #^$hook 420 "*" {
		tabkey.addnick $servernum() $0
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*" {
		for sref in ($serverrefs()) {
			tabkey.addnick $sref =$0
		}
	}
}

on #^dcc_request 420 "% CHAT *"
{
	for sref in ($serverrefs()) {
		tabkey.addnick $sref =$0
	}
}

on #^send_ctcp 420 "PRIVMSG % DCC CHAT *"
{
	for sref in ($serverrefs()) {
		tabkey.addnick $sref =$1
	}
}


/****** STARTUP ******/

/*
 * DEFAULT COMPLETION RULES
 * I will add a user interface to add/remove these in the near future.
 *
 * Warning: Currently spaces are ignored here but tabs are not. If you use
 * tabs for readability your completion procedure will be rejected.
 */

/*
 * We have to add rule 0 manually because $word() sees "" as a missing
 * argument and fails. This rule is also exempt from tabkey.addrule's
 * duplicate rule check since $matchitem() matches "" and "*".
 */
@ setitem(tabkey.rules 0 "")
@ setitem(tabkey.rinfo 0 msg !DO NOT REMOVE!)

tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "#%"                 channel
tabkey.addrule "* #%"               channel
tabkey.addrule "/%"                 command
tabkey.addrule "/config %"          config
tabkey.addrule "/dset %"            config
tabkey.addrule "/format %"          format
tabkey.addrule "/fset %"            format
tabkey.addrule "/set %"             set
tabkey.addrule "/loadmod *"         mods
tabkey.addrule "/reloadmod *"       lmods
tabkey.addrule "/save *"            lmods
tabkey.addrule "/theme *"           theme
tabkey.addrule "/unloadmod *"       lmods
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel
tabkey.addrule "/join *"            channel
tabkey.addrule "/j *"               channel
tabkey.addrule "/leave *"           channel
tabkey.addrule "/part *"            channel
tabkey.addrule "/mode %"            channel
tabkey.addrule "/m #%"              channel
tabkey.addrule "/msg #%"            channel
tabkey.addrule "/assign %"          assign
tabkey.addrule "/push %"            assign
tabkey.addrule "/pop %"             assign
tabkey.addrule "/shift %"           assign
tabkey.addrule "/unshift %"         assign


/* EOF */