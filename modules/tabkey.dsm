#version 0.2.2
/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * TABKEY.DSM - Tab key module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 1/22/02 (bmw)
 *
 * This script uses serial number 420 for all /on hooks.
 */

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_connect 420 -"% CHAT *"

	^alias -cleartab

	@ delarray(tabkey_rules)
	@ delarray(tabkey_rinfo)

	^bind ^I toggle_insert_mode
}

config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX :


bind ^I parse_command tabkey.process_tabkey


alias cleartab (void)
{
	xecho -s -b Clearing tabkey history...

	for var in ($aliasctl(assign match TABKEY.NICKS.))
	{
		^assign -$var
	}

	for var in ($aliasctl(assign match TABKEY.INDEX.))
	{
		^assign -$var
	}
}


/*
 * tabkey.addrule <pattern> <routine> [word list]
 *
 * Adds a new completion rule. Both <pattern> and [word list] MUST be double
 * quoted or things will break.
 *
 * Routines that take word lists:         channel, nick
 * Routines that do NOT take word lists:  command, config, file, format,
 *                                        lmods, mods, msg
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule
{
	@ :pattern = word(0 $*)
	^local pattern \"$pattern\"
	@ :routine = word(1 $*)
	@ :list = word(2 $*)

	if (!pattern || !routine)
	{
		xecho -b Error: tabkey.addrule: Not enough arguments
		return
	}

	/*
	 * We check for > 0 here instead of > -1 because rule 0 (pattern: "")
	 * would match rules with patterns like "*", and we don't want that.
	 */
	if (matchitem(tabkey_rules $pattern) > 0)
	{
		xecho -b Error: tabkey.addrule: Pattern $pattern already exists in current rules
		return
	}

	if (match($routine channel nick))
	{
		if (!list)
		{
			xecho -b Error: tabkey.addrule: Routine [$routine] requires a word list
			return
		}
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $routine $list)
	} \
	elsif (match($routine command config file format lmods mods msg))
	{
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $routine)
	}{
		xecho -b Error: tabkey.addrule: Invalid completion routine [$routine]
	}
}

/*
 * Adds nicks to the msg_routine history. This will keep separate lists for
 * each server you are connected to.
 */
alias tabkey.addnick (nick, void)
{
	if (match($nick $TABKEY.NICKS[$winserv()]))
	{
		@ TABKEY.NICKS.$winserv() = remw($nick $TABKEY.NICKS[$winserv()])
	}

	if (numwords($TABKEY.NICKS[$winserv()]) == CONFIG[TABKEY_NICK_HISTORY])
	{
		shift TABKEY.NICKS.$winserv()
	}

	@ push(TABKEY.NICKS[$winserv()] $nick)
	@ TABKEY.INDEX.$winserv() = [-1]

	return
}

alias tabkey.display_rules (void)
{
	echo #   Pattern                      Routine    Word List
	for cnt from 0 to ${numitems(tabkey_rules) - 1}
	{
		@ :pattern = getitem(tabkey_rules $cnt)
		@ :routine = word(0 $getitem(tabkey_rinfo $cnt))
		@ :list = restw(1 $getitem(tabkey_rinfo $cnt))
		@ :num = cnt + 1
		echo $[3]num $[28]pattern $[10]routine ${list ? list : []}
	}
}

alias tabkey.process_tabkey (void)
{
	@ :item = rmatchitem(tabkey_rules "$L")

	if (item > -1)
	{
		@ :tmp = getitem(tabkey_rinfo $item)
		@ :routine = word(0 $tmp)
		eval ^local list $restw(1 $tmp)

		switch ($tolower($routine))
		{
			(channel) { @ tabkey.channel_routine($list) }
			(command) { parsekey command_completion }
			(config)  { @ tabkey.set_routine(CONFIG) }
			(file)    { @ tabkey.file_routine() }
			(format)  { @ tabkey.set_routine(FORMAT) }
			(lmods)   { @ tabkey.module_routine(loaded_modules) }
			(mods)    { @ tabkey.module_routine(modules) }
			(msg)     { @ tabkey.msg_routine() }
			(nick)    { @ tabkey.nick_routine($list) }
			(*) {
				xecho -b Illegal completion routine specified [$routine] \(item: $item\)
			}
		}
	}
}
	

/*
 * COMPLETION ROUTINES
 * These do all the dirty work. Currently there is a lot of duplicate code
 * so this could probably use some optimization.
 */

alias tabkey.channel_routine (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	if (lastc == [ ])
	{
		if (#list == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $list$space
		}
	}{
		@ :lastw = word(${#L - 1} $L)
		@ lastw = sar(g/\\/\\\\\/$lastw)
		@ :findchan = pattern($lastw% $list)
		
		if (match($lastw $findchan))
		{
			xecho -b Matches:
			echo $findchan
		}
		
		if (#findchan == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $findchan$space
		} \
		elsif (#findchan > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findchan)
			
			@ :lastw = word(${#L - 1} $L)
			if (!match($lastw $findchan))
			{
				xecho -b Matches:
				echo $findchan
			}
		}
	}
	
	return
}

alias tabkey.file_routine (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)

	unless (lastc == [ ])
	{
		@ :lastw = twiddle($word(${#L - 1} $L))
		@ :findfile = pattern($lastw% $glob($lastw*))
		
		if (#findfile == 1)
		{
			@ :lastc = mid(${strlen($findfile) - 1} 1 $findfile)
			parsekey delete_to_previous_space
			xtype -l $findfile${lastc == [/] ? [] : [ ]}
		} \
		elsif (#findfile > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findfile)

			xecho -b Matches:
			for file in ($findfile)
			{
				echo $file
			}
		}
	}
	
	return
}

alias tabkey.module_routine (array, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		^local modules
		
		for cnt from 1 to $numitems($array)
		{
			@ :itm = cnt - 1
			@ push(modules $getitem($array $itm))
		}
		
		@ :lastw = word(${#L - 1} $L)
		@ :findmod = pattern($lastw% $modules)

		if (match($word(1 $L) $findmod))
		{
			xecho -b Matches:
			echo $findmod
		}
		
		if (#findmod == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $findmod$space
		} \
		elsif (#findmod > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findmod)

			if (!match($word(1 $L) $findmod))
			{
				xecho -b Matches:
				echo $findmod
			}
		}
	}

	return
}

alias tabkey.msg_routine (void)
{
	@ :nicks = TABKEY.NICKS[$winserv()]
	@ :index = TABKEY.INDEX[$winserv()]
	@ :msg_cmd = CMDCHARS ## [msg]
	@ :trailing = restw(2 $L)

	if (nicks)
	{
		if (index > 0)
		{
			@ :nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		}{
			@ :nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}

		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	}{
		@ TABKEY.INDEX.$winserv() = [-1]
	}

	return
}

alias tabkey.nick_routine (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	if (lastc == [ ])
	{
		if (#list == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $list$space
		}
	}{
		@ :lastw = word(${#L - 1} $L)
		@ lastw = sar(g/\\/\\\\\/$lastw)
		@ :findnick = pattern($lastw% $list)

		if (match($word(1 $L) $findnick))
		{
			xecho -b Matches:
			echo $findnick
		}
		
		if (#findnick == 1)
		{
			if (#L == 1)
			{
				@ :space = CONFIG[TABKEY_NICKCOMP_SUFFIX] ## [ ]
			}{
				@ :space = [ ]
			}
			parsekey delete_to_previous_space
			xtype -l $findnick$space
		} \
		elsif (#findnick > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findnick)

			if (!match($word(1 $L) $findnick))
			{
				xecho -b Matches:
				echo $findnick
			}
		}
	}

	return
}

alias tabkey.set_routine (type, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)

	unless (lastc == [ ])
	{
		^local newvars

		if (left(1 $word(1 $L)) == [-])
		{
			@ :rmflag = 1
			@ :word1 = strip(- $word(1 $L))
		}{
			@ :word1 = word(1 $L)
		}
		
		@ :cur_value = aliasctl(assign get $type\.$word1)
		@ :findvar = aliasctl(assign match $type\.$word1)
		
		for var in ($findvar)
		{
			@ push(newvars $after(1 . $var))
		}
		
		if (cur_value)
		{
			xecho -b Matches:
			echo $newvars
		}
		
		if (#newvars == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$newvars$space
		} \
		elsif (#newvars > 1)
		{
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$prefix($newvars)

			@ :cur_value = aliasctl(assign get $type\.$word(1 $L))

			if (!cur_value)
			{
				xecho -b Matches:
				for var in ($newvars)
				{
					echo $var
				}
			}
		}
	}
	
	return
}


/*
 * Passes the nicks of people you are chatting with through $tabkey.addnick()
 * to put them into the msg_routine history.
 */
for hook in (msg send_msg)
{ 
	on #^$hook 420 "*"
	{
		@ tabkey.addnick($0)
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*"
	{
		@ tabkey.addnick(=$0)
	}
}

on #^dcc_connect 420 "% CHAT *"
{
	@ tabkey.addnick(=$0)
}


/*
 * DEFAULT COMPLETION RULES
 * I will add a user interface to add/remove these in the near future.
 *
 * We have to add rule 0 manually because $word() sees "" as a missing
 * argument and fails. This rule is also exempt from tabkey.addrule's
 * duplicate rule check since $matchitem() matches "" and "*".
 */
@ setitem(tabkey_rules 0 "")
@ setitem(tabkey_rinfo 0 msg !DO NOT REMOVE!)

tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "*#%"                channel     "$mychannels()"
tabkey.addrule "/%"                 command
tabkey.addrule "/config %"          config
tabkey.addrule "/dset %"            config
tabkey.addrule "/format %"          format
tabkey.addrule "/fset %"            format
tabkey.addrule "/loadmod *"         mods
tabkey.addrule "/reloadmod *"       lmods
tabkey.addrule "/save *"            lmods
tabkey.addrule "/unloadmod *"       lmods
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel     "$mychannels()"
tabkey.addrule "/join *"            channel     "$mychannels()"
tabkey.addrule "/j *"               channel     "$mychannels()"
tabkey.addrule "/leave *"           channel     "$mychannels()"
tabkey.addrule "/part *"            channel     "$mychannels()"
tabkey.addrule "/mode %"            channel     "$mychannels()"


/* bmw '01 */