#version 0.1
/* $Id$ */
/*
 * tabkey.dsm - Tab key completion module for DarkStar/EPIC4
 * Copyright (c) 2002 EPIC Software Labs
 * See the 'COPYRIGHT' file for more information.
 *
 * This script is based on the tabkey.ce script that is distributed with
 * the EPIC4 IRC client and written by CrazyEddy. Most of the important
 * code comes from there.
 *
 * Converted and maintained for DarkStar by Brian Weiss <brian@epicsol.org>.
 * Please report bugs to me, not CE.
 *
 * This script uses serial number 420 for all /ON hooks.
 *
 * Original header follows, with modifications where necessary.
 *
 *  -bmw
 */

#
# OK, here's the plan:
#
# tabkey.main cuts the input line up into edible chunks, and selects a function
# to do the actual completion.  The function will receive a single word as
# its argument, and return a list of potential matches.  The word is whatever
# is under the cursor, up to the insertion point at the current time.  The
# word may be empty and the function should be able to cope with this.
#
# The exact function chosen works like this:
# * If the current _word_ is a command (first word, begins with $cmdchars),
#   call command_completion by way of parsekey (don't call any aliases).
# * Or, if the current line is a command, it gets handed to $tabkey.cmd().
# * Otherwise, call tabkey.default, which is a stub that can be changed
#   to suit your preferences.  The default tabkey.default calls
#   tabkey.nickchan which matches against all channels you're currently on
#   and either the nicks in your current channel, or failing that, the
#   nicks in all channels.
# * tabkey.default is also called if tabkey.cmd() returns nothing.  If
#   necessary, the function can prevent this behaviour by returning a single
#   space, but this is discouraged.
# * tabkey.default is also called by $tabkey.cmd() if it cannot find an
#   appropriate command handler.
# * $tabkey.cmd() will search for an appropriate function by joining the
#   command and all its arguments together with dots and progressively
#   removing those arguments until a function is found.
#
# tabkey "exports" a number of local variables that the functions may use
#   or alter after using "bless":
# * $curword is what tabkey believes the current word is.  The function
#   may make use of this for context sensitivity.  I say believes because
#   this may be open to different interpretations.
# * $wordind is the character index of the _beginning_ of the word that is
#   being completed.  If it is equal to $curpos(), then the first argument
#   will be empty and the user has hit tab at the beginning of the word or
#   in between words and the function should return all possible matches.
#   The reason you may need to use it is if the function is designed to
#   complete something that is not a single word.  It, and the current
#   cursor position may be altered to cause tabkey to replace the chosen
#   part of the string instead of just the word.
#
# The organisation of the supporting functions goes like this:
# * "Context sensitive" functions are to be named with "tabkey.cmd." as a
#   prefix followed by the name of the command that they are used to
#   complete.  This is where tabkey.cmd will look for them.
# * Generally, completion "methods" should be placed under tabkey.method
#   and shouldn't rely on the exported variables being available, as user
#   supplied functions may forget to re-export them.  Context sensitive
#   functions should be as simple as possible.
#

queue cleanup.tabkey {
	^bind ^I toggle_insert_mode
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_request 420 -"% CHAT *"
	^on #send_ctcp 420 -"PRIVMSG % DCC CHAT *"
}

config.add TABKEY_MAX_NICKHIST 6
config.add TABKEY_NICKCOMP_SUFFIX ,

bind ^I parse_command tabkey.main

alias tabkey.default {
	bless
	if (L == []) {
		@:ret = tabkey.cmd.msg($*)
	} else if (curword == 0) {
		@:matches = tabkey.method.nick($*)
		if (#matches == 1) {
			@:ret = matches ## CONFIG.TABKEY_NICKCOMP_SUFFIX
		} else {
			@:ret = matches
		}
	} else {
		@:ret = tabkey.method.nickchan($*)
	}
	return $ret
}

alias tabkey.main {
	@ :curword = indextoword($curpos() $L )
	@ :wordind = wordtoindex($curword $L)
	if (32 >= (127 & ascii($mid(${curpos()-1} 1 $L )))) {
		@ curword++
		@ wordind = curpos()
	}
	@ :word = mid($wordind ${curpos()-wordind} $L)
	@ :matches = []
	if (!index($cmdchars $L)) {
		wait for @ matches = tabkey.cmd($word)
	} else {
		wait for @ :matches = tabkey.default($word)
	}
	@ :prefix = prefix($matches)
	if (1 < numwords($matches) && word == prefix) {
		echo Completions for \"$word\": $matches
	} elsif (#matches && strlen($word) <= strlen($prefix)) {
		repeat ${curpos()-wordind} parsekey backspace
		xtype -l $prefix${1 < #matches ? [] : [ ]}
	}
}

alias tabkey.addnicktohist (server, nick, void) {
	if (server == [] || !nick) {
		echo Error: tabkey.addnicktohist: Not enough arguments
		return
	}
	if (match($nick $TABKEY.MSGHIST[$server])) {
		@ TABKEY.MSGHIST.$server = remw($nick $TABKEY.MSGHIST[$server])
	}
	if (numwords($TABKEY.MSGHIST[$server]) == CONFIG.TABKEY_MAX_NICKHIST) {
		shift TABKEY.MSGHIST.$server
	}
	push TABKEY.MSGHIST[$server] $nick
	@ TABKEY.HISTINDEX.$server = -1
}

alias tabkey.cmd {
	bless
	@ :ret = :cmd = []
	@ :pass = chr($jot($ascii(AZ)))
	@ :pass#= chr($jot($ascii(az)))
	@ :pass#= chr($jot($ascii(09)))
	@ :args = mid(0 $curpos() $L)
	@ :args = unsplit(. $args)
	@ :args = pass(._$pass $args)
	if (!curword) {
		@ ret = tabkey.method.commands($args)
		repeat $#ret {push ret /$shift(ret)}
		return $ret
	}
	while (args) {
		@ :matches = aliasctl(alias pmatch tabkey.cmd.$args*)
		@ :matches = prefix($matches)
		if (aliasctl(alias exists $matches) && matches == [tabkey.cmd.$args]) {
			@ args = matches
			break
		}
		@ args = before(-1 . $args)
	}
	if (args) {
		wait for @ ret = ${args}($*)
	}
	unless (strlen($ret)) {
		wait for @ ret = tabkey.default($*)
	}
	return $ret
}

# Context sensitive completion goes here.

alias tabkey.cmd.alias  { return $tabkey.method.aliasctl(alias); }

alias tabkey.cmd.assign { return $tabkey.method.aliasctl(assign); }

alias tabkey.cmd.channel tabkey.cmd.join

alias tabkey.cmd.config tabkey.cmd.dset

alias tabkey.cmd.dcc    { return $pattern("$0*" CHAT CLOSE CLOSEALL GET LIST RAW RENAME RESUME SEND); }
alias tabkey.cmd.dcc.resume tabkey.cmd.dcc.send
alias tabkey.cmd.dcc.send {
	bless
	switch ($curword) {
		(0) {echo This should never happen.;call}
		(1) {echo This should never happen.;call}
		(2) {return $tabkey.method.nick($*)}
		(*) {return $tabkey.method.file($*)}
	}
}

alias tabkey.cmd.do tabkey.cmd.eval

alias tabkey.cmd.dset { return $tabkey.method.config(CONFIG); }

alias tabkey.cmd.eval { return $tabkey.method.commands($*); }

alias tabkey.cmd.exec { return $tabkey.method.filei($*); }

alias tabkey.cmd.foreach {
	bless
	if (curword == 1 && left(1 $word) == [-]) {
		@:ret = tabkey.method.aliasctl(alias)
	} else if (curword == 1) {
		@:ret = tabkey.method.aliasctl(assign)
	}
	return $ret
}

alias tabkey.cmd.fset { return $tabkey.method.config(FORMAT); }

alias tabkey.cmd.help {
	bless
	@ :matches = []
	@ :path = restw(1 $left($curpos() $L))
	if (wordind == curpos()) {@ push(path *)}
	@ matches = globi($unsplit(/ $getset(HELP_PATH) $path*))
	repeat $#matches @ push(matches $rightw(1 $remws(/ $split(/ $shift(matches)))))
	return $matches
}

alias tabkey.cmd.ignore {
	bless
	if (curword == 1) {
		@:ret = tabkey.method.mask($*)
	} else if (curword > 1) {
		@:ret = pattern("$0*" ALL CRAP CTCPS INVITES JOINS MSGS NICKS NONE NOTES NOTICES PARTS PUBLIC TOPICS WALLS WALLOPS)
	}
	return $ret
}

alias tabkey.cmd.j tabkey.cmd.join
alias tabkey.cmd.join    { return $tabkey.method.chan($*); }

alias tabkey.cmd.l tabkey.cmd.leave
alias tabkey.cmd.leave   { return $tabkey.method.chan($*); }

alias tabkey.cmd.less    { return $tabkey.method.filei($*); }

alias tabkey.cmd.load    { return $tabkey.method.filei($*); }

alias tabkey.cmd.loadmod { return $tabkey.method.arrays(modules); }

alias tabkey.cmd.mode {
	bless
	if (curword == 1) {
		@:ret = tabkey.method.chan($*)
	} else {
		@:ret = tabkey.method.nick($*)
	}
	return $ret
}

alias tabkey.cmd.m tabkey.cmd.msg
alias tabkey.cmd.msg {
	bless
	if (curword == 1) {
		@:ret = tabkey.method.nickchan($*)
	} else {
		@:cmd = word(0 $L)
		if (!cmd) {
			@:cmd = [$K\MSG]
		}
		@:nicks = TABKEY.MSGHIST[$winserv()]
		@:index = TABKEY.HISTINDEX[$winserv()]
		@:trailing = restw(2 $L)
		if (nicks) {
			if (index > 0) {
				@:nick = word(${index - 1} $nicks)
				@ TABKEY.HISTINDEX.$winserv() = index - 1
			} else {
				@:nick = word(${numwords($nicks) - 1} $nicks)
				@ TABKEY.HISTINDEX.$winserv() = numwords($nicks) - 1
			}
			parsekey erase_line
			xtype -l $cmd $nick $trailing
			@:ret = [ ]
		} else {
			@ TABKEY.HISTINDEX.$winserv() = -1
		}
	}
	return $ret
}

alias tabkey.cmd.part tabkey.cmd.leave

alias tabkey.cmd.pop       { return $tabkey.method.aliasctl(assign); }
alias tabkey.cmd.push      { return $tabkey.method.aliasctl(assign); }

alias tabkey.cmd.q tabkey.cmd.query
alias tabkey.cmd.query     { return $tabkey.method.nickchan($*); }

alias tabkey.cmd.reloadmod { return $tabkey.method.arrays(loaded_modules); }

alias tabkey.cmd.save      { return $tabkey.method.arrays(loaded_modules); }

alias tabkey.cmd.set {
	bless
	if (curword == 1) {
		@:ret = getsets($word%)
	} else if (curword == 2 && word == []) {
		eval xtype -l \$$word(${curword - 1} $L)
		@:ret = [ ]
	}
	return $ret
}

alias tabkey.cmd.shift     { return $tabkey.method.aliasctl(assign); }

alias tabkey.cmd.status    { return $tabkey.method.arrays(status); }

alias tabkey.cmd.theme     { return $tabkey.method.arrays(themes); }

alias tabkey.cmd.unloadmod { return $tabkey.method.arrays(loaded_modules); }

alias tabkey.cmd.unshift   { return $tabkey.method.aliasctl(assign); }

alias tabkey.cmd.window {
	bless
	@:windowcmds        = [ADD BACK BALANCE BEEP_ALWAYS BIND CHANNEL CLEAR CREATE DELETE DESCRIBE DISCON DOUBLE ECHO FIXED FLUSH GOTO GROW HIDE HIDE_OTHERS HOLD_INTERVAL HOLD_MODE KILL KILL_OTHERS KILLSWAP LAST LASTLOG LASTLOG_LEVEL LEVEL LIST LOG LOGFILE MOVE NAME NEW NEW_HIDE NEXT NOSERV NOTIFIED NOTIFY NOTIFY_LEVEL NUMBER POP PREVIOUS PROMPT PUSH QUERY REFNUM REFNUM_OR_SWAP REFRESH REMOVE SCRATCH SCROLL SCROLLBACK SERVER SHOW SHOW_ALL SHRINK SIZE SKIP STACK STATUS_FORMAT STATUS_FORMAT1 STATUS_FORMAT2 STATUS_SPECIAL SWAP UNBIND]
	if (curword == 1) {
		@:cmd = [WINDOW]
	} else {
		@:cmd = word(${curword - 1} $L)
	}
	switch ($toupper($cmd)) {
		(ADD) (QUERY) (REMOVE) {
			@:ret = tabkey.method.nickchan($*)
		}
		(BEEP_ALWAYS) (DOUBLE) (FIXED) (HOLD_MODE) (LOG) (SCRATCH) (SCROLL) (SKIP) {
			@:ret = pattern("$word*" ON OFF TOGGLE)
		}
		(BIND) (CHANNEL) {
			@:ret = tabkey.method.chan($*)
		}
		(ECHO) (GOTO) (GROW) (HOLD_INTERVAL) (LASTLOG) (MOVE) (NAME) (NUMBER) (PROMPT) (REFNUM) (REFNUM_OR_SWAP) (SCROLLBACK) (SERVER) (SHRINK) (SIZE) (STATUS_%) (SWAP) {
			@:nocomp = 1
		}
		(LASTLOG_LEVEL) (LEVEL) (NOTIFY_LEVEL) {
			if (match(%,% $word)) {
				@:word_a = before(-1 , $word)
				@:word_b = after(-1 , $word)
			}
			@:list = [ACTIONS CRAP CTCP DCC MSGS NOTES NOTICES OPNOTES PUBLIC SNOTES USERLOG1 USERLOG2 USERLOG3 USERLOG4 WALLOPS WALLS]
		}
		(LOGFILE) {
			@:list = tabkey.method.file($*)
		}
		(*) {
			@:list = windowcmds
		}
	}
	if (word_a) {
		@:matches = pattern("$word_b*" $list)
		if (#matches == 1) {
			parsekey delete_to_previous_space
			xtype -l $word_a\,$matches${[ ]}
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l $word_a\,$prefix($matches)
			echo Completions for \"$word_b\": $matches
		}
		@:ret = [ ]
	} else if (nocomp) {
		@:ret = [ ]
	} else {
		@:ret = pattern("$word*" $list)
	}
	return $ret
}


# Methods.

alias tabkey.method.aliasctl (type, void) {
	bless
	if (!type) {
		return
	}
	if (curword == 1) {
		if (left(1 $word) == [-]) {
			@:rm = 1
			@:foo = rest(1 $word)
		} else {
			@:foo = word
		}
		@:matches = pattern("$foo*" $aliasctl($type match $foo))
		if (#matches == 1) {
			@:ret = rm ? [-$matches] : matches
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			echo Completions for \"$foo\": $matches
			@:ret = [ ]
		}
	} else if (curword == 2 && word == []) {
		eval xtype -l \$$word(${curword - 1} $L)
		@:ret = [ ]
	}
	return $ret
}

alias tabkey.method.arrays (array, void) {
	bless
	@:list = []
	for ii from 0 to ${numitems($array) - 1} {
		push list $getitem($array $ii)
	}
	@:list = sort($uniq($list))
	if (word == []) {
		@:ret = list
	} else {
		@:ret = pattern("$word*" $list)
	}
	return $ret
}

alias tabkey.method.commands {
	@ :ret = sort($uniq($getcommands($**) $aliasctl(alias match $*) $aliasctl(alias match $**)))
	return $ret
}

alias tabkey.method.config (struct, void) {
	bless
	if (curword == 1) {
		if (left(1 $word) == [-]) {
			@:rm = 1
			@:foo = rest(1 $word)
		} else {
			@:foo = word
		}
		@:matches = []
		for var in ($aliasctl(assign match $struct\.$foo)) {
			push matches $after(1 . $var)
		}
		if (#matches == 1) {
			@:ret = rm ? [-$matches] : matches
		} else if (#matches > 1) {
			parsekey delete_to_previous_space
			xtype -l ${rm ? [-] : []}$prefix($matches)
			echo Completions for \"$foo\": $matches
			@:ret = [ ]
		}
	} else if (curword == 2 && word == [] && (left(1 $word(${curword - 1} $L)) != [-])) {
		eval xtype -l \$$struct\.$word(${curword - 1} $L)
		@:ret = [ ]
	}
	return $ret
}

alias tabkey.method.chan { return $pattern("$0*" $mychannels()); }
alias tabkey.method.notify { return $pattern("$0*" $notify(on)); }

alias alias.foo alias $*;alias $sar(g/globi/glob/$sar(g/filei/file/$*))
alias.foo tabkey.method.filei {
	@ :f0 = :f1 = globi("$0*")
	while (numwords($f0) == 1 && f0 =~ [*/]) {
		@ f0 = globi($f0*)
	}
	return ${f0 ? f0 : f1}
}
alias -alias.foo

alias tabkey.method.mask {
	bless
	if (word) {
		@:uhost = userhost($word)
		if (uhost == [<UNKNOWN>@<UNKNOWN>]) {
			@:uhost = uh($word)
		}
		unless (uhost == [<UNKNOWN>@<UNKNOWN>]) {
			@:ret = word ## [!] ## uhost
		}
	}
	return $ret
}

alias tabkey.method.nick {
	if (pattern("$0*" $chanusers())) {
		return $pattern($0* $chanusers());
	} else {
		@ :chanusers = []
		fe ($mychannels()) chan {
			@ push(chanusers $chanusers($chan))
		}
		return $pattern("$0*" $sort($uniq($chanusers)));
	}
}

alias tabkey.method.nickchan {
	return $remws(/ $tabkey.method.chan($*) $tabkey.method.nick($*))
}

alias tabkey.method.nickchannotify {
	return $remws(/ $tabkey.method.chan($*) $sort($uniq($tabkey.method.nick($*) $tabkey.method.notify($*))))
}


/*
 * Add the nicks of users that you're chatting with to the msg history.
 */
for hook in (msg send_msg) {
	on #^$hook 420 "*" {
		tabkey.addnicktohist $servernum() $0
	}
}

for hook in (dcc_chat send_dcc_chat) {
	on #^$hook 420 "*" {
		for sref in ($serverrefs()) {
			tabkey.addnicktohist $sref =$0
		}
	}
}

on #^dcc_request 420 "% CHAT *" {
	for sref in ($serverrefs()) {
		tabkey.addnicktohist $sref =$0
	}
}


/* EOF */