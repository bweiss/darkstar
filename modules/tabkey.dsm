#version 0.6.3
/* $Id$ */
/*
 * tabkey.dsm - Tab key module for Darkstar/EPIC4
 *
 * Written by Brian Weiss
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 420 for all /on hooks.
 */

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_request 420 -"% CHAT *"
	^on #send_ctcp 420 -"PRIVMSG % DCC CHAT *"

	^alias -cleartab

	@ delarray(tabkey_rules)
	@ delarray(tabkey_rinfo)

	^bind ^I toggle_insert_mode
}


config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX ,

assign MODINFO.TABKEY.1 Completion rules: $numitems(tabkey_rules)


bind ^I parse_command tabkey.process_tabkey


alias cleartab (void)
{
	purge TABKEY.NICKS
	purge TABKEY.INDEX
	xecho -b Tabkey history cleared
}


/*
 * tabkey.addrule <pattern> <procedure> [word list]
 *
 * Adds a new completion rule. Both <pattern> and [word list] MUST be double
 * quoted or things will break. The <procedure> argument should be the member
 * name of an existing tabkey procedure (tabkey.proc.<procedure>).
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule
{
	@ :pattern = word(0 $*)
	^local pattern \"$pattern\"
	@ :proc = word(1 $*)
	@ :list = word(2 $*)

	if (!pattern || !proc)
	{
		xecho -b Error: tabkey.addrule: Not enough arguments
		return
	}

	/*
	 * We check for > 0 here instead of > -1 because rule 0 (pattern: "")
	 * would match rules with patterns like "*", and we don't want that.
	 */
	if (matchitem(tabkey_rules $pattern) > 0)
	{
		xecho -b Error: tabkey.addrule: Pattern $pattern already exists in current rules
		return
	}

	if (aliasctl(alias match tabkey.proc.$proc))
	{
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $proc${list ? [ $list] : []})
	}{
		xecho -b Error: tabkey.addrule: Invalid completion procedure [$proc]
	}
}

/*
 * tabkey.addnick <nick> <server refnum>
 *
 * Adds <nick> to the msg history for <server refnum>. This will keep
 * separate lists for each server you are connected to.
 */
alias tabkey.addnick (nick, server, void)
{
	if (!nick || server == [])
	{
		xecho -b Error: tabkey.addnick: Not enough arguments
		return
	}

	if (match($nick $TABKEY.NICKS[$server]))
	{
		@ TABKEY.NICKS.$server = remw($nick $TABKEY.NICKS[$server])
	}

	if (numwords($TABKEY.NICKS[$server]) == CONFIG[TABKEY_NICK_HISTORY])
	{
		shift TABKEY.NICKS.$server
	}

	@ push(TABKEY.NICKS[$server] $nick)
	@ TABKEY.INDEX.$server = [-1]
}

alias tabkey.display_rules (void)
{
	echo #   Pattern                    Procedure    Word List
	for cnt from 0 to ${numitems(tabkey_rules) - 1}
	{
		@ :pattern = getitem(tabkey_rules $cnt)
		@ :proc = word(0 $getitem(tabkey_rinfo $cnt))
		@ :list = restw(1 $getitem(tabkey_rinfo $cnt))
		@ :num = cnt + 1
		echo $[3]num $[26]pattern $[12]proc ${list ? list : []}
	}
}

/*
 * tabkey.rmrule <pattern>
 *
 * Removes a rule that matches <pattern>. Just like everywhere else, the
 * pattern should be encased in double quotes.
 */
alias tabkey.rmrule (...)
{
	@ :item = matchitem(tabkey_rules $*)
	if (item > 0)
	{
		@ delitem(tabkey_rules $item)
		@ delitem(tabkey_rinfo $item)
	}
}

/*
 * tabkey.show_matches <list>
 *
 * Beeps the terminal and displays the <list> of matches when the tabkey is
 * pressed a second time. This is intended to be used by the completion
 * procedures since almost all of them want it.
 */
alias tabkey.show_matches (list)
{
	if (!list)
	{
		return
	}

	if (L == TABKEY[LAST_INPUT] && strlen($L) == strlen($TABKEY.LAST_INPUT))
	{
		beep
		xecho -b Matches:
		for tmp in ($list)
		{
			echo $tmp
		}
	}
}

/*
 * This is called whenever the user actually pushes the Tab key.
 */
alias tabkey.process_tabkey (void)
{
	@ :item = rmatchitem(tabkey_rules "$L")
	if (item > -1)
	{
		@ :rinfo = getitem(tabkey_rinfo $item)
		@ :proc = word(0 $rinfo)
		eval ^local list $restw(1 $rinfo)
		tabkey.proc.$proc $list
		@ TABKEY.LAST_INPUT = L
	}
}

	
/*
 * COMPLETION PROCEDURES
 * These will be called by tabkey.process_tabkey when a matching completion
 * rule is found. In order to be recognized as a valid completion procedure
 * (in rules) they must be in the tabkey.proc structure. Anything not in this
 * structure is being called by something that is.
 */

alias tabkey.array_proc (array, void)
{
	^local items
	for cnt from 0 to ${numitems($array) - 1}
	{
		@ push(items $getitem($array $cnt))
	}

	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		@ :matches = items
	}{
		@ :lastw = word(${#L - 1} $L)
		@ :matches = pattern($lastw% $items)
	}

	if (#matches == 1)
	{
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	}\
	else if (#matches > 1)
	{
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.channel (list)
{
	if (!list)
	{
		@ :list = mychannels()
	}

	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		@ :matches = list
	}{
		@ :lastw = word(${#L - 1} $L)
		/* This allows us to complete channels with "\" in them. */
		@ :lastw = sar(g/\\/\\\\\/$lastw)
		@ :matches = pattern($lastw% $list)
	}

	if (#matches == 1)
	{
		parsekey delete_to_previous_space
		xtype -l $matches${[ ]}
	}\
	else if (#matches > 1)
	{
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.command (void)
{
	if (strlen($L) == 1)
	{
		parsekey command_completion
	}{
		@ :matches = getcommands($rest(1 $L)%)
		if (!matches)
		{
			@ :matches = aliasctl(alias match $rest(1 $L))
		}

		if (#matches == 1)
		{
			parsekey erase_line
			xtype -l /$matches${[ ]}
		}\
		else if (#matches > 1)
		{
			parsekey erase_line
			xtype -l /$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.file (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		@ :lastw = twiddle($word(${#L - 1} $L))
		@ :matches = pattern($lastw% $glob($lastw*))
		
		if (#matches == 1)
		{
			@ :lastc = mid(${strlen($matches) - 1} 1 $matches)
			parsekey delete_to_previous_space
			xtype -l $matches${lastc == [/] ? [] : [ ]}
		}\
		else if (#matches > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.lmods (void)
{
	tabkey.array_proc loaded_modules
}

alias tabkey.proc.mods (void)
{
	tabkey.array_proc modules
}

alias tabkey.proc.msg (void)
{
	@ :nicks = TABKEY.NICKS[$winserv()]
	@ :index = TABKEY.INDEX[$winserv()]
	@ :msg_cmd = CMDCHARS ## [msg]
	@ :trailing = restw(2 $L)

	if (nicks)
	{
		if (index > 0)
		{
			@ :nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		}{
			@ :nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}

		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	}{
		@ TABKEY.INDEX.$winserv() = [-1]
	}
}

alias tabkey.proc.nick (list)
{
	if (!list)
	{
		@ :list = onchannel()
	}

	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	if (lastc == [ ])
	{
		@ :matches = list
	}{
		@ :lastw = word(${#L - 1} $L)
		/* This allows us to complete nicks with "\" in them. */
		@ :lastw = sar(g/\\/\\\\\/$lastw)
		if (#L < 2)
		{
			@ :suffix = CONFIG[TABKEY_NICKCOMP_SUFFIX] ## [ ]
		}{
			@ :suffix = [ ]
		}
		@ :matches = pattern($lastw% $list)
	}

	if (#matches == 1)
	{
		parsekey delete_to_previous_space
		xtype -l $matches$suffix
	}\
	else if (#matches > 1)
	{
		parsekey delete_to_previous_space
		xtype -l $prefix($matches)
		tabkey.show_matches $matches
	}
}

alias tabkey.proc.config (void)
{
	tabkey.set_proc config
}

alias tabkey.proc.format (void)
{
	tabkey.set_proc format
}

alias tabkey.proc.set (void)
{
	tabkey.set_proc set
}

alias tabkey.set_proc (type, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	unless (lastc == [ ])
	{
		/* Deal with the removal of variables correctly. */
		if (left(1 $word(1 $L)) == [-])
		{
			@ :rmflag = 1
			@ :word1 = strip(- $word(1 $L))
		}{
			@ :word1 = word(1 $L)
		}
		
		if (tolower($type) == [set])
		{
			@ :matches = getsets($word1%)
		}{
			^local matches
			for var in ($aliasctl(assign match $type\.$word1))
			{
				@ push(matches $after(1 . $var))
			}
		}
		
		if (#matches == 1)
		{
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$matches${[ ]}
		}\
		else if (#matches > 1)
		{
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$prefix($matches)
			tabkey.show_matches $matches
		}
	}
}

alias tabkey.proc.theme (void)
{
	tabkey.array_proc themes
}


/*
 * Add the nicks of people you are chatting with to the msg history.
 */
for hook in (msg send_msg)
{ 
	on #^$hook 420 "*"
	{
		tabkey.addnick $0 $servernum()
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*"
	{
		tabkey.addnick =$0 $servernum()
	}
}

on #^dcc_request 420 "% CHAT *"
{
	tabkey.addnick =$0 $servernum()
}

on #^send_ctcp 420 "PRIVMSG % DCC CHAT *"
{
	tabkey.addnick =$1 $servernum()
}


/*
 * DEFAULT COMPLETION RULES
 * I will add a user interface to add/remove these in the near future.
 *
 * Warning: Currently spaces are ignored here but tabs are not. If you use
 * tabs for readability your completion procedure will be rejected.
 */

/*
 * We have to add rule 0 manually because $word() sees "" as a missing
 * argument and fails. This rule is also exempt from tabkey.addrule's
 * duplicate rule check since $matchitem() matches "" and "*".
 */
@ setitem(tabkey_rules 0 "")
@ setitem(tabkey_rinfo 0 msg !DO NOT REMOVE!)

tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "#%"                 channel
tabkey.addrule "* #%"               channel
tabkey.addrule "/%"                 command
tabkey.addrule "/config %"          config
tabkey.addrule "/dset %"            config
tabkey.addrule "/format %"          format
tabkey.addrule "/fset %"            format
tabkey.addrule "/set %"             set
tabkey.addrule "/loadmod *"         mods
tabkey.addrule "/reloadmod *"       lmods
tabkey.addrule "/save *"            lmods
tabkey.addrule "/theme *"           theme
tabkey.addrule "/unloadmod *"       lmods
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel
tabkey.addrule "/join *"            channel
tabkey.addrule "/j *"               channel
tabkey.addrule "/leave *"           channel
tabkey.addrule "/part *"            channel
tabkey.addrule "/mode %"            channel
tabkey.addrule "/m #%"              channel
tabkey.addrule "/msg #%"            channel


/* EOF */