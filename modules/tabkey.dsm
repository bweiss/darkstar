#version 0.2
/*     _             _        _
 *  __| | __ _  _ _ | |__ ___| |_  __ _  _ _
 * / _` |/ _` || '_|| / /(_-<|  _|/ _` || '_|
 * \__,_|\__,_||_|  |_\_\/__/ \__|\__,_||_|
 *
 * TABKEY.DSM - Tab key module for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 1/21/02 (bmw)
 *
 * This script uses serial number 420 for all /on hooks.
 */

queue cleanup.tabkey
{
	^on #msg 420 -"*"
	^on #send_msg 420 -"*"
	^on #dcc_chat 420 -"*"
	^on #send_dcc_chat 420 -"*"
	^on #dcc_connect 420 -"% CHAT *"

	^alias -cleartab

	@ delarray(tabkey_rules)
	@ delarray(tabkey_rinfo)

	^bind ^I toggle_insert_mode
}

config.add TABKEY_NICK_HISTORY 6
config.add TABKEY_NICKCOMP_SUFFIX :


bind ^I parse_command tabkey.process_tabkey


alias cleartab (void)
{
	xecho -s -b Clearing tabkey history...

	for var in ($aliasctl(assign match TABKEY.NICKS.))
	{
		^assign -$var
	}

	for var in ($aliasctl(assign match TABKEY.INDEX.))
	{
		^assign -$var
	}
}


/*
 * tabkey.addrule <pattern> <routine> [word list]
 *
 * Adds a new completion rule. Both <pattern> and [word list] MUST be double
 * quoted or things will break.
 *
 * Routines that take word lists:         channel, nick
 * Routines that do NOT take word lists:  command, config, file, format,
 *                                        lmods, mods, msg
 *
 * Example: tabkey.addrule "/foo *" channel "$mychannels()"
 */
alias tabkey.addrule (...)
{
	@ :pattern = word(0 $*)
	@ :routine = word(1 $*)
	@ :list = word(2 $*)

	if (!pattern || !routine)
	{
		tabkey.addrule: Not enough arguments
		return
	}

	if (match($routine channel nick))
	{
		if (!list)
		{
			xecho -b tabkey.addrule: Routine [$routine] requires a word list
			return
		}
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $routine $list)
	} \
	elsif (match($routine command config file format lmods mods msg))
	{
		@ setitem(tabkey_rules $numitems(tabkey_rules) $pattern)
		@ setitem(tabkey_rinfo $numitems(tabkey_rinfo) $routine)
	}{
		xecho -b tabkey.addrule: Invalid completion routine [$routine]
	}
}

alias tabkey.display_rules (void)
{
	echo #   Pattern                      Routine    Word List
	for cnt from 0 to ${numitems(tabkey_rules) - 1}
	{
		@ :pattern = getitem(tabkey_rules $cnt)
		^assign pattern \"$pattern\"
		@ :routine = word(0 $getitem(tabkey_rinfo $cnt))
		@ :list = restw(1 $getitem(tabkey_rinfo $cnt))
		@ :num = cnt + 1
		echo $[3]num $[28]pattern $[10]routine ${list ? [\"$list\"] : []}
	}
}

alias tabkey.process_tabkey (void)
{
	if (!L)
	{
		/*
		 * This is the only hardcoded routine. An unfortunate side effect
		 * of "*" matching nothing.
		 */
		@ tabkey.msg_routine()
	}{
		@ :item = rmatchitem(tabkey_rules $L)

		if (item > -1)
		{
			@ :tmp = getitem(tabkey_rinfo $item)
			@ :routine = word(0 $tmp)
			eval ^local list $restw(1 $tmp)

			switch ($tolower($routine))
			{
				(channel) {@ tabkey.channel_routine($list)}
				(command) {parsekey command_completion}
				(config) {@ tabkey.set_routine(CONFIG)}
				(file) {@ tabkey.file_routine()}
				(format) {@ tabkey.set_routine(FORMAT)}
				(lmods) {@ tabkey.module_routine(loaded_modules)}
				(mods) {@ tabkey.module_routine(modules)}
				(msg) {@ tabkey.msg_routine()}
				(nick) {@ tabkey.nick_routine($list)}
				(*) {
					xecho -b Illegal completion routine specified [$routine]
				}
			}
		}
	}
}
	
alias tabkey.add_nick (nick, void)
{
	if (match($nick $TABKEY.NICKS[$winserv()]))
	{
		@ TABKEY.NICKS.$winserv() = remw($nick $TABKEY.NICKS[$winserv()])
	}

	if (numwords($TABKEY.NICKS[$winserv()]) == CONFIG[TABKEY_NICK_HISTORY])
	{
		shift TABKEY.NICKS.$winserv()
	}

	@ push(TABKEY.NICKS[$winserv()] $nick)
	@ TABKEY.INDEX.$winserv() = [-1]

	return
}

alias tabkey.channel_routine (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	if (lastc == [ ])
	{
		if (#list == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $list$space
		}
	}{
		@ :lastw = word(${#L - 1} $L)
		@ lastw = sar(g/\\/\\\\\/$lastw)
		@ :findchan = pattern($lastw% $list)
		
		if (match($lastw $findchan))
		{
			xecho -b Matches:
			echo $findchan
		}
		
		if (#findchan == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $findchan$space
		} \
		elsif (#findchan > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findchan)
			
			@ :lastw = word(${#L - 1} $L)
			
			if (!match($lastw $findchan))
			{
				xecho -b Matches:
				echo $findchan
			}
		}
	}
	
	return
}

alias tabkey.file_routine (void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)

	unless (lastc == [ ])
	{
		@ :lastw = twiddle($word(${#L - 1} $L))
		@ :findfile = pattern($lastw% $glob($lastw*))
		
		if (#findfile == 1)
		{
			@ :lastc = mid(${strlen($findfile) - 1} 1 $findfile)
 			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l $findfile${lastc == [/] ? [] : [ ]}
		} \
		elsif (#findfile > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findfile)

			xecho -b Matches:
			for file in ($findfile)
			{
				echo $file
			}
		}
	}
	
	return
}

alias tabkey.module_routine (array, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		^local modules
		
		for cnt from 1 to $numitems($array)
		{
			@ :itm = cnt - 1
			@ push(modules $getitem($array $itm))
		}
		
		@ :lastw = word(${#L - 1} $L)
		@ :findmod = pattern($lastw% $modules)

		if (match($word(1 $L) $findmod))
		{
			xecho -b Matches:
			echo $findmod
		}
		
		if (#findmod == 1)
		{
			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l $findmod$space
		} \
		elsif (#findmod > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findmod)

			if (!match($word(1 $L) $findmod))
			{
				xecho -b Matches:
				echo $findmod
			}
		}
	}

	return
}

alias tabkey.msg_routine (void)
{
	@ :nicks = TABKEY.NICKS[$winserv()]
	@ :index = TABKEY.INDEX[$winserv()]
	@ :msg_cmd = CMDCHARS ## [msg]
	@ :trailing = restw(2 $L)

	if (nicks)
	{
		^local nick

		if (index > 0)
		{
			@ nick = word(${index - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = index - 1
		}{
			@ nick = word(${numwords($nicks) - 1} $nicks)
			@ TABKEY.INDEX.$winserv() = numwords($nicks) - 1
		}

		parsekey erase_line
		xtype -l $msg_cmd $nick $trailing
	}{
		@ TABKEY.INDEX.$winserv() = [-1]
	}

	return
}

alias tabkey.nick_routine (list)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	if (lastc == [ ])
	{
		if (#list == 1)
		{
			@ :space = [ ]
			parsekey delete_to_previous_space
			xtype -l $list$space
		}
	}{
		@ :lastw = word(${#L - 1} $L)
		@ lastw = sar(g/\\/\\\\\/$lastw)
		@ :findnick = pattern($lastw% $list)

		if (match($word(1 $L) $findnick))
		{
			xecho -b Matches:
			echo $findnick
		}
		
		if (#findnick == 1)
		{
			^local space

			if (#L == 1)
			{
				@ space = CONFIG[TABKEY_NICKCOMP_SUFFIX] ## [ ]
			}{
				@ space = [ ]
			}
		
			parsekey delete_to_previous_space
			xtype -l $findnick$space
		} \
		elsif (#findnick > 1)
		{
			parsekey delete_to_previous_space
			xtype -l $prefix($findnick)

			if (!match($word(1 $L) $findnick))
			{
				xecho -b Matches:
				echo $findnick
			}
		}
	}

	return
}

alias tabkey.set_routine (type, void)
{
	@ :lastc = mid(${strlen($L) - 1} 1 $L)
	
	unless (lastc == [ ])
	{
		^local newvars,rmflag,word1
		
		if (left(1 $word(1 $L)) == [-])
		{
			^assign rmflag 1
			@ word1 = strip(- $word(1 $L))
		}{
			@ word1 = word(1 $L)
		}
		
		@ :cur_value = aliasctl(assign get $type\.$word1)
		@ :findvar = aliasctl(assign match $type\.$word1)
		
		for var in ($findvar)
		{
			@ push(newvars $after(1 . $var))
		}
		
		if (cur_value)
		{
			xecho -b Matches:
			echo $newvars
		}
		
		if (#newvars == 1)
		{
			@ :space = [ ]
			
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$newvars$space
		} \
		elsif (#newvars > 1)
		{
			parsekey delete_to_previous_space
			xtype -l ${rmflag ? [-] : []}$prefix($newvars)

			@ :cur_value = aliasctl(assign get $type\.$word(1 $L))

			if (!cur_value)
			{
				xecho -b Matches:
				for var in ($newvars)
				{
					echo $var
				}
			}
		}
	}
	
	return
}


for hook in (msg send_msg)
{ 
	on #^$hook 420 "*"
	{
		@ tabkey.add_nick($0)
	}
}

for hook in (dcc_chat send_dcc_chat)
{
	on #^$hook 420 "*"
	{
		@ tabkey.add_nick(=$0)
	}
}

on #^dcc_connect 420 "% CHAT *"
{
	@ tabkey.add_nick(=$0)
}


/*
 * Setup default completion rules.
 */
tabkey.addrule "*"                  nick        "$remw($: $onchannel()) $:"
tabkey.addrule "*#%"                channel     "$mychannels()"
tabkey.addrule "/%"                 command
tabkey.addrule "/config %"          config
tabkey.addrule "/dset %"            config
tabkey.addrule "/format %"          format
tabkey.addrule "/fset %"            format
tabkey.addrule "/loadmod *"         mods
tabkey.addrule "/reloadmod *"       lmods
tabkey.addrule "/save *"            lmods
tabkey.addrule "/unloadmod *"       lmods
tabkey.addrule "/dcc send % %"      file
tabkey.addrule "/less *"            file
tabkey.addrule "/load *"            file
tabkey.addrule "/exec *"            file
tabkey.addrule "/msg %"             nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/m %"               nick        "$remw($: $onchannel()) $:"
tabkey.addrule "/msg % *"           msg
tabkey.addrule "/m % *"             msg
tabkey.addrule "/channel *"         channel     "$mychannels()"
tabkey.addrule "/join *"            channel     "$mychannels()"
tabkey.addrule "/j *"               channel     "$mychannels()"
tabkey.addrule "/leave *"           channel     "$mychannels()"
tabkey.addrule "/part *"            channel     "$mychannels()"
tabkey.addrule "/mode %"            channel     "$mychannels()"


/* bmw '01 */