#version 0.2.1
/*
 * CHANNEL.DSM - Channel related stuff for Darkstar/EPIC4
 * Author: Brian Weiss <brian@epicsol.org> - 2001
 *
 * Last modified: 2/17/02 (bmw)
 *
 * This script uses serial numbers 0 and 424 for /on hooks.
 */

queue cleanup.channel
{
	for alias in (alldeop alldop allop ban bankick banlist bans bk cmode cycle deop dop devoice dvoice i invite j join k kb key kick kickban l leave lk massmode mdeop mdop mdevoice mdvoice mop mvoice oldtopic op part partall setoldtopic t tban tempban unban unkey untopic voice wall wall2)
	{
		^alias -$alias
	}

	@ delarray(oldtopics)
	@ delarray(tban)
	
	^on public -'% % *\\\\\[\${CONFIG[AUTO_RESPONSE_STR]}\\\\\]*'
	^on public_other -'% % *\\\\\[\${CONFIG[AUTO_RESPONSE_STR]}\\\\\]*'
	^on send_action -'\\\\\[#* &* +*\\\\\] *'

	for hook in (332 333 367 368 369 action channel_signoff channel_sync join leave mode public public_other send_public topic)
	{
		^on $hook -"*"
	}
}


config.add -b AUTO_RESPONSE 0
config.add -b AUTO_RESPONSE_BEEP 0
config.add    AUTO_RESPONSE_STR
config.add    BANTYPE 3
config.add    DEFAULT_KICK_REASON No soup for you!
config.add -b SHOW_OPVOICE_IN_PUBLICS 0

format.add ACTION_CHANNEL * $1 $3-
format.add ACTION_CHANNEL_OTHER * $1/$2 $3-
format.add BANS $[3]1 $[12]5  $strftime($6 %%x@%%X)  $4
format.add BANS_FOOTER $G Total bans on $3: $2
format.add BANS_HEADER #   SetBy         When               Ban
format.add CHANNEL_SIGNOFF $G SignOff $2: $1 \($3-%n\) [$tolower($Z)]
format.add CHANNEL_SYNC $G Channel $1 synced in $2 seconds
format.add CHANNEL_TS $G Channel $2 created $strftime($3 %%a %%b %%T %%Z %%Y) [$3]
format.add JOIN $G $1 \($3\) has joined $2 at $Z
format.add LEAVE $G $1 \($3\) has left $2 at $Z
format.add MODE $G Mode change \"$3-\" on channel $2 by $1
format.add PUBLIC <$1> $3-
format.add PUBLIC_AR <%W$1%n> $3-
format.add PUBLIC_OTHER <$1:$2> $3-
format.add PUBLIC_OTHER_AR <%W$1%n:$2> $3-
format.add SEND_ACTION_CHANNEL * $servernick() $2-
format.add SEND_ACTION_CHANNEL_OTHER * -> $1: $servernick() $2-
format.add SEND_PUBLIC <$2> $3-
format.add SEND_PUBLIC_OTHER <$1:$2> $3-
format.add TOPIC $G Topic for $2: $3-
format.add TOPIC_CHANGE $G $1 has changed the topic on channel $2 to $3-
format.add TOPIC_SETBY $G The topic was set by $3 on $strftime($4 %%c)


alias alldop alldeop
alias bans banlist
alias bk bankick
alias dop deop
alias dvoice devoice
alias i invite
alias j join
alias k kick
alias kb kickban
alias l leave
alias mdop mdeop
alias mdvoice mdevoice
alias part leave
alias t topic


alias alldeop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /alldeop <nick1> [nick2] [nick3] ...
		return
	}

	for chan in ($mychannels())
	{
		for nick in ($nicks)
		{
			if (ischanop($servernick() $chan) && ischanop($nick $chan))
			{
				//mode $chan -o $nick
			}
		}
	}
}

alias allop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /allop <nick1> [nick2] [nick3] ...
		return
	}

	for chan in ($mychannels())
	{
		for nick in ($nicks)
		{
			if (ischanop($servernick() $chan) && onchannel($nick $chan) && !ischanop($nick $chan))
			{
				//mode $chan +o $nick
			}
		}
	}
}

alias ban (targets)
{
	^local bans,mode

	if (!targets)
	{
		xecho -b Usage: /ban <nick|ban>
		return
	}

	for target in ($targets)
	{
		if (onchannel($target $C))
		{
			push bans $mask($CONFIG.BANTYPE $userhost($target))
		}{
			push bans $target
		}
	}

	fe ($bans) b1 b2 b3 b4
	{
		^local mode +
		for ban in ($b1 $b2 $b3 $b4)
		{
			if (ban) @ mode = mode ## [b]
		}

		//mode $C $mode $b1 $b2 $b3 $b4
	}
}

alias bankick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /bankick <nick> [reason]
		return
	}

	ban $nick
	//kick $C $nick $reason
}

alias banlist (chan default "$C", void)
{
	//mode $chan +b
}

alias cmode (mode, ...)
{
	if (!mode)
	{
		xecho -b Usage: /cmode <modes>
		return
	}

	//mode $C $mode $*
}

alias cycle (chan default "$C", void)
{
	@ :key = key($chan)
	//part $chan
	wait
	//join $chan $key
}

alias deop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /deop <nick1> [nick2] ...
		return
	}

	massmode $C - o $nicks
}

alias devoice (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /devoice <nick1> [nick2] ...
		return
	}

	massmode $C - v $nicks
}

alias invite (nick, channel default "$C", void)
{
	if (!nick)
	{
		xecho -b Usage: /invite <nick> [channel]
		return
	}

	//invite $nick $channel
}

/*
 * Taken from 2.8script distributed with EPIC.
 */
alias join
{
	switch ($*)
	{
		(#*) (&*) (0) (-*) (!*) (*,*) {//join $*}
		() {//join -i}
		(*) {//join #$*}
	}
}

alias key (key, void)
{
	if (!key)
	{
		xecho -b Usage: /key <key>
		return
	}

	//mode $C +k $key
}

alias kick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /kick <nick> [reason]
		return
	}

	//kick $C $nick $reason
}

alias kickban (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /kickban <nick> [reason]
		return
	}

	//kick $C $nick $reason
	ban $nick
}

/*
 * Taken from 2.8script distributed with EPIC.
 */
alias leave
{
	switch ($0)
	{
		(#*) (&*) (0) (-*) (!*) (*,*) {//leave $*}
		() (\*) {//leave * $1-}
		(*) {//leave #$*}
	}
}

/* 
 * Your standard /LK. Kicks everyone but +o and +v people out of the current
 * channel.
 */
alias lk (reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!ischanop($N $C))
	{
		xecho -b Sorry, you gotta be +o to kick people
		return
	}

	^local ask $"Kick all non-ops from $C? "

	if (toupper($left(1 $ask)) == [Y])
	{
		for user in ($channel())
		{
			@ :nick = mid(2 $strlen($user) $user)

			if (match(.. $left(2 $user)))
			{
				//kick $C $nick $reason
			} \
			else if (match(.? $left(2 $user)))
			{
				//kick $C $nick $reason
			}
		}
	}
}

alias massmode (chan, action, mode, ...)
{
	if (!chan || !action || !mode || ![$*])
	{
		xecho -b Usage: /massmode <channel> <+|-> <mode> <mode parameters>
		return
	}

	fe ($*) a1 a2 a3 a4
	{
		//mode $chan $action $repeat(4 $mode) $a1 $a2 $a3 $a4
	}
}

alias mdeop (chan default "$C", void)
{
	massmode $chan - o $remw($servernick() $chops($chan))
}

alias mdevoice (chan default "$C", void)
{
	massmode $chan - v $remw($servernick() $onchannel($chan))
}

alias mop (chan default "$C", void)
{
	massmode $chan + o $remw($servernick() $nochops($chan))
}

alias mvoice (chan default "$C", void)
{
	massmode $chan + v $remw($servernick() $onchannel($chan))
}

alias oldtopic (chan default "$C", void)
{
	@ :oldtopic = gettmatch(oldtopics $chan*)
	if (oldtopic)
	{
		xecho -b Last topic for $chan: $restw(1 $oldtopic)
	}{
		xecho -b There is no old topic for $chan
	}
}
			
alias op (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /op <nick1> [nick2] [...]
		return
	}

	massmode $C + o $nicks
}

alias partall (void)
{
	input "Are you sure you want to part all your channels? "
	{
		if (toupper($left(1 $0)) == [Y])
		{
			for chan in ($mychannels())
			{
				//part $chan
			}
		}
	}
}

alias setoldtopic (chan default "$C", void)
{
	@ :oldtopic = gettmatch(oldtopics $chan*)
	if (oldtopic)
	{
		//topic $oldtopic
	}{
		xecho -b There is no old topic for $chan
	}
}

alias tban (chan default "$C", void)
{
	@ delarray(tban)

	^on #^367 424 "% $chan *"
	{
		@ setitem(tban $numitems(tban) $*)
	}

	^on #^368 424 "% % $chan"
	{
		^local bans
		^local chan $2
		^local tmp $"Which ban(s) to remove? (1, 2-5, ...) "

		for bannum in ($tmp)
		{
			@ :startban = before(- $bannum)
			@ :endban = after(- $bannum)

			if (startban < endban && startban < numitems(tban) && endban <= numitems(tban))
			{
				for cnt from $startban to $endban
				{
					push bans $word(2 $getitem(tban ${cnt - 1}))
				}
			} \
			else if (bannum <= numitems(tban))
			{
				push bans $word(2 $getitem(tban ${bannum - 1}))
			}
		}

		fe ($bans) b1 b2 b3 b4
		{
			^local mode -
			for ban in ($b1 $b2 $b3 $b4)
			{
				if (ban) @ mode = mode ## [b]
			}

			//mode $chan $mode $b1 $b2 $b3 $b4
		}

		^on #^367 424 -"% $chan *"
		^on #^368 424 -"% % $chan"
	}

	//mode $chan +b
}

alias tempban (time, target, void)
{
	if (!time || !target)
	{
		xecho -b Usage: /tempban <seconds> <nick|ban>
		return
	}

	if (onchannel($target $C))
	{
		//mode $C +b $mask($CONFIG.BANTYPE $userhost($target))
		timer $time //mode $C -b $mask($CONFIG.BANTYPE $userhost($target))
	}{
		//mode $C +b $target
		timer $time //mode $C -b $target
	}
}

alias unban (bans)
{
	if (!bans)
	{
		xecho -b Usage: /unban <ban1> [ban2] [ban3] ...
		return
	}

	for ban in ($bans)
	{
		//mode $C -b $ban
	}
}

alias unkey (void)
{
	if (match(*k* $chanmode()))
	{
		//mode $C -k
	}{
		xecho -b No key on channel $C
	}
}

alias untopic (chan default "$C", void)
{
	//topic -$chan
}

alias voice (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /voice <nick1> [nick2] [...]
		return
	}

	massmode $C + v $nicks
}

alias wall (text)
{
	if (!text)
	{
		xecho -b Usage: /wall <text>
		return
	}

	fe ($filter($N $chops())) o1 o2 o3 o4 o5 o6 o7
	{
		^notice $o1,$o2,$o3,$o4,$o5,$o6,$o7 [wall/$C] $text
	}
	xecho -l walls -- * > [wall/$C] $text
}

alias wall2 (text)
{
	if (!text)
	{
		xecho -b Usage: /wall2 <text>
		return
	}

	^notice $sar(g/#/#@/$C) [wall/$C] $text
	xecho -l walls -- * > [wall/$C] $text
}


/*
 * Functions
 */
alias channel.show_ov (nick, chan, void)
{
	if (CONFIG[SHOW_OPVOICE_IN_PUBLICS])
	{
		@ function_return = ischanop($nick $chan) ? [@] ## nick : ischanvoice($nick $chan) ? [+] ## nick : nick
	}{
		@ function_return = nick
	}
}


/*
 * ON hooks
 */
on ^329 "*"
{
	if (FORMAT[CHANNEL_TS])
	{
		echo $fparse(CHANNEL_TS $*)
	}
}

on ^332 "*"
{
	if (FORMAT[TOPIC])
	{
		echo $fparse(TOPIC $*)
	}

	if (!getmatches(topics $1*))
	{
		@ setitem(topics $numitems(topics) $1-)
	}
}

on ^333 "*"
{
	if (FORMAT[TOPIC_SETBY])
	{
		echo $fparse(TOPIC_SETBY $*)
	}
}


/*
 * Ban list stuff (367 368 369)
 */
on ^367 "*"
{
	@ setitem(banlist.$1 $numitems(banlist.$1) $*)
}

on ^368 "*"
{
	if ([$1] > 0)
	{
		if (FORMAT[BANS_HEADER])
		{
			echo $fparse(BANS_HEADER $*)
		}

		if (FORMAT[BANS])
		{
			@ :endcnt = numitems(banlist.$2) - 1
			for cnt from 0 to $endcnt
			{
				echo $fparse(BANS ${cnt + 1} $getitem(banlist.$2 $cnt))
			}
		}

		if (FORMAT[BANS_FOOTER])
		{
			echo $fparse(BANS_FOOTER $*)
		}

		@ delarray(banlist.$2)
	}{
		xecho -b There are no bans on $2
	}
}

on ^369 "*" #

on ^action "*"
{
	if (iscurchan($1))
	{
		if (FORMAT[ACTION_CHANNEL])
		{
			echo $fparse(ACTION_CHANNEL $*)
		}
	}{
		if (FORMAT[ACTION_CHANNEL_OTHER])
		{
			echo $fparse(ACTION_CHANNEL_OTHER $*)
		}
	}
}

on ^channel_signoff "*"
{
	if (FORMAT[CHANNEL_SIGNOFF])
	{
		echo $fparse(CHANNEL_SIGNOFF $*)
	}
}

on ^channel_sync "*"
{
	if (FORMAT[CHANNEL_SYNC])
	{
		echo $fparse(CHANNEL_SYNC $*)
	}
}

on ^join "*"
{
	if (FORMAT[JOIN])
	{
		echo $fparse(JOIN $*)
	}
}

on ^leave "*"
{
	if (FORMAT[LEAVE])
	{
		echo $fparse(LEAVE $*)
	}
}

on ^mode "*"
{
	if (FORMAT[MODE])
	{
		echo $fparse(MODE $*)
	}
}

on ^public "*"
{
	if (FORMAT[PUBLIC])
	{
		echo $fparse(PUBLIC $channel.show_ov($0 $1) $1-)
	}
}

on ^public_other "*"
{
	if (FORMAT[PUBLIC_OTHER])
	{
		echo $fparse(PUBLIC_OTHER $channel.show_ov($0 $1) $1-)
	}
}

on ^send_action '\\[#* &* +*\\] *'
{
	if (iscurchan($0))
	{
		if (FORMAT[SEND_ACTION_CHANNEL])
		{
			echo $fparse(SEND_ACTION_CHANNEL $*)
		}
	}{
		if (FORMAT[SEND_ACTION_CHANNEL_OTHER])
		{
			echo $fparse(SEND_ACTION_CHANNEL_OTHER $*)
		}
	}
}

on ^send_public "*"
{
	if ([$0] == C)
	{
		if (FORMAT[SEND_PUBLIC])
		{
			echo $fparse(SEND_PUBLIC $0 $channel.show_ov($servernick() $0) $1-)
		}
	}{
		if (FORMAT[SEND_PUBLIC_OTHER])
		{
			echo $fparse(SEND_PUBLIC_OTHER $channel.show_ov($servernick() $0) $*)
		}
	}
}

on ^topic "*"
{
	if (FORMAT[TOPIC_CHANGE])
	{
		echo $fparse(TOPIC_CHANGE $*)
	}

	@ :topic_itm = matchitem(topics $1*)
	
	if (topic_itm > -1)
	{
		@ :oldtopic_itm = matchitem(oldtopics $1*)
		
		if (oldtopic_itm > -1)
		{
			@ delitem(oldtopics $oldtopic_itm)
		}
		
		@ setitem(oldtopics $numitems(oldtopics) $getitem(topics $topic_itm))
		@ delitem(topics $topic_itm)
	}

	@ setitem(topics $numitems(topics) $1-)
}

/*
 * Auto-response
 */
on ^public '% % *\\[${CONFIG[AUTO_RESPONSE_STR]}\\]*'
{
	if (CONFIG[AUTO_RESPONSE])
	{
		if (FORMAT[PUBLIC_AR])
		{
			echo $fparse(PUBLIC_AR $channel.show_ov($0 $1) $1-)
		}

		if (CONFIG[AUTO_RESPONSE_BEEP])
		{
			if (BEEP == [OFF])
			{
				^set BEEP ON
				//beep
				^set BEEP OFF
			}{
				//beep
			}
		}
	}{
		if (FORMAT[PUBLIC])
		{
			echo $fparse(PUBLIC $channel.show_ov($0 $1) $1-)
		}
	}
}

on ^public_other '% % *\\[${CONFIG[AUTO_RESPONSE_STR]}\\]*'
{
	if (CONFIG[AUTO_RESPONSE])
	{
		if (FORMAT[PUBLIC_OTHER_AR])
		{
			echo $fparse(PUBLIC_OTHER_AR $channel.show_ov($0 $1) $1-)
		}

		if (CONFIG[AUTO_RESPONSE_BEEP])
		{
			if (BEEP == [OFF])
			{
				^set BEEP ON
				//beep
				^set BEEP OFF
			}{
				//beep
			}
		}
	}{
		if (FORMAT[PUBLIC_OTHER])
		{
			echo $fparse(PUBLIC_OTHER $channel.show_ov($0 $1) $1-)
		}
	}
}


/* bmw '01 */