#version 1.1.3
/* $Id$ */
/*
 * channel.dsm - Channel related module for DarkStar/EPIC4
 * Copyright (c) 2002, 2003 Brian Weiss (except where noted)
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 424 for /ON hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.channel
{
	for alias in (addtopic alldeop alldop allop ban bankick banlist bans bk cmode cycle deop dop devoice dvoice et etopic i invite j join k kb key kick kickban l leave lk massmode mdeop mdop mdevoice mdvoice mme mop msay mvoice op part partall settopic t tban tempban tempbk tempkb topics tt ttopic unban unkey untopic voice wall) {
		^alias -$alias
	}

	for hook in (332 333 367 368 369 action channel_nick channel_signoff channel_sync invite join kick leave mode public public_other send_public topic) {
		^on $hook -"*"
	}

	^on send_action -'\\\\\[#* &* +*\\\\\] *'
	^on #hook 428 -"CONFIG CHANNEL_WALL_TYPE *"
	^on #hook 428 -"CONFIG REMEMBER_TOPICS *"
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add    ADDTOPIC_DELIMETER ||
config.add -b AUTO_RESPONSE 0
config.add -b AUTO_RESPONSE_BEEP 0
config.add -b AUTO_RESPONSE_NOTIFY 0
config.add    AUTO_RESPONSE_STR
config.add    BANTYPE 3
config.add    CHANNEL_WALL_TYPE 1
config.add    DEFAULT_KICK_REASON No soup for you!
config.add    MAX_MODES 4
config.add    REMEMBER_TOPICS 5

format.add ACTION_CHANNEL * $1 $3-
format.add ACTION_CHANNEL_OTHER * $1/$2 $3-
format.add BANS $G $1-
format.add BANS_FOOTER $G Total number of bans on $3 - $2
format.add BANS_FOOTER1
format.add BANS_FOOTER2
format.add BANS_HEADER
format.add BANS_HEADER1
format.add BANS_HEADER2
format.add CHANNEL_NICK $G $2 is now known as $3
format.add CHANNEL_SIGNOFF $G SignOff $2: \($3-%n\)
format.add CHANNEL_SYNC $G Channel $1 synced in $2 seconds
format.add CHANNEL_TS $G Channel $2 was created at $strftime($3 %%a %%b %%d %%T %%Z %%Y)
format.add INVITE $G $1 \($3\) invites you to channel $2
format.add JOIN $G $1 \($3\) has joined $2
format.add KICK $G ${[$1] == servernick() ? [You have] : [$1 has]} been kicked off channel $3 by $2 \($4-\)
format.add LEAVE $G $1 \($3\) has left $2
format.add MODE $G Mode change \"$3-\" on channel $2 by $1
format.add PUBLIC <$1> $3-
format.add PUBLIC_AR <$1> $3-
format.add PUBLIC_OTHER <$1:$2> $3-
format.add PUBLIC_OTHER_AR <$1:$2> $3-
format.add SEND_ACTION_CHANNEL * $1 $3-
format.add SEND_ACTION_CHANNEL_OTHER * -> $2: $1 $3-
format.add SEND_PUBLIC > $3-
format.add SEND_PUBLIC_OTHER $2> $3-
format.add SEND_WALL -@$1-> $2-
format.add TOPIC $G Topic for $2: $3-
format.add TOPIC_CHANGE $G $1 has changed the topic on channel $2 to $3-
format.add TOPIC_SETBY $G The topic was set by $3 $4 sec ago
format.add TOPIC_UNSET $G $1 has changed the topic on channel $2 to


/****** USER ALIASES ******/

alias addtopic (newtopic)
{
	if (!newtopic)
	{
		xecho -b Usage: /ADDTOPIC <text>
		return
	}

	if (!C)
	{
		xecho -b No active channel for this window
		return
	}

	@ :serv = winserv()
	@ :array = [channel.topics.$serv\.$C]
	@ :topic = getitem($array ${numitems($array) - 1})

	if (topic)
	{
		//topic $C $topic $CONFIG.ADDTOPIC_DELIMETER $newtopic
	}{
		@ CHANNEL.ADDTOPIC = newtopic

		/* No topic set */
		^on -331 "% $C *" {
			//topic $1 $CHANNEL.ADDTOPIC
			@ CHANNEL.ADDTOPIC = []
			defer ^on 331 -"% $1 *"
			defer ^on 332 -"% $1 *"
			defer ^on 333 -"% $1 *"
		}

		/* The actual topic */
		^on ^332 "% $C *" {
			//topic $1 $2- $CONFIG.ADDTOPIC_DELIMETER $CHANNEL.ADDTOPIC
			@ CHANNEL.ADDTOPIC = []
			defer ^on 332 -"% $1 *"
		}

		/* Topic set by */
		^on ^333 "% $C *" {
			defer ^on 333 -"% $1 *"
		}

		//topic
	}
}

alias alldop alldeop

alias alldeop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /ALLDEOP <nick> ...
		return
	}

	for chan in ($mychannels())
	{
		for nick in ($nicks)
		{
			if (ischanop($servernick() $chan) && ischanop($nick $chan)) {
				//mode $chan -o $nick
			}
		}
	}
}

alias allop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /ALLOP <nick> ...
		return
	}

	for chan in ($mychannels())
	{
		for nick in ($nicks)
		{
			if (ischanop($servernick() $chan) && onchannel($nick $chan) && !ischanop($nick $chan)) {
				//mode $chan +o $nick
			}
		}
	}
}

alias ban (targets)
{
	if (!targets)
	{
		xecho -b Usage: /BAN <nick|hostmask> ...
		return
	}

	^local bans
	for target in ($targets)
	{
		switch ($pass(!@. $target))
		{
			() {
				/*
				 * Target is a nickname. Attempt to get the user@host from
				 * $userhost() or $uh() then pass it through $mask(). If
				 * both functions fail to return a usable host, just pass
				 * the target through and let the client handle it.
				 */
				@ :uhost = userhost($target) == [<UNKNOWN>@<UNKNOWN>] ? uh($target) : userhost($target)
				/* Check again in case $uh() failed too. */
				if (uhost && uhost != [<UNKNOWN>@<UNKNOWN>]) {
					push bans $mask($CONFIG.BANTYPE $uhost)
				} else {
					push bans $target
				}
			}

			(.) {
				/* Target is a hostname or IP, pass it through $mask() only. */
				push bans $mask($CONFIG.BANTYPE $target)
			}

			(*) {
				/* Target is already a hostmask, just pass it on through. */
				push bans $target
			}
		}
	}

	massmode $C + b $bans

	/*
	 * Allow this alias to be called as a function so that /TEMPBAN
	 * can use it to do the banning but still know which hostmask to
	 * remove from the ban list later.
	 */
	if (functioncall()) {
		@ function_return = bans
	}
}

alias bk bankick

alias bankick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /BANKICK <nick> [reason]
		return
	}

	ban $nick
	if (onchannel($nick $C)) {
		//kick $C $nick $reason
	}
}

alias bans banlist

alias banlist (chan default "$C", void)
{
	//mode $chan +b
}

alias cmode (mode, ...)
{
	if (!mode)
	{
		xecho -b Usage: /CMODE <modes>
		return
	}

	//mode $C $mode $*
}

alias cycle (chan default "$C", void)
{
	@ :key = key($chan)
	//part $chan
	wait
	//join $chan $key
}

alias dop deop

alias deop (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /DEOP <nick> ...
		return
	}

	massmode $C - o $nicks
}

alias dvoice devoice

alias devoice (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /DEVOICE <nick> ...
		return
	}

	massmode $C - v $nicks
}

alias et etopic

/*
 * Edit the current topic. This places "/TOPIC <current topic>" on the
 * input line so that you can edit it and re-set it.
 */
alias etopic (void)
{
	if (C)
	{
		/*
		 * Attempt to get the current topic from a channel.topics array
		 * but query the server if that fails.
		 */
		@ :serv = winserv()
		@ :array = [channel.topics.$serv\.$C]
		@ :topic = getitem($array ${numitems($array) - 1})

		if (topic)
		{
			parsekey erase_line
			xtype -l $K\TOPIC $topic
		}{
			/* No topic set */
			^on -331 "% $C *" {
				defer ^on 331 -"% $1 *"
				defer ^on 332 -"% $1 *"
				defer ^on 333 -"% $1 *"
			}

			/* The actual topic */
			^on ^332 "% $C *" {
				parsekey erase_line
				xtype -l $K\TOPIC $2-
				defer ^on 332 -"% $1 *"
			}

			/* Topic set by */
			^on ^333 "% $C *" {
				defer ^on 333 -"% $1 *"
			}

			//topic
		}
	}
}

alias i invite

alias invite (nick, channel default "$C", void)
{
	if (!nick)
	{
		xecho -b Usage: /INVITE <nick> [channel]
		return
	}

	//invite $nick $channel
}

/*
 * /JOIN taken from 2.8script, distributed with EPIC.
 */
alias j join
alias join
{
	switch ($*)
	{
		(*,*)
		{
			join $before(, $0) $1-
			join $after(, $0) $1-
		}
		(#*) (&*) (0) (-*) (!*) (+*)
			{ //join $* }
		()
			{ //join -i }
		(*)
			{ //join #$* }
	}
}

alias key (key, void)
{
	if (!key)
	{
		xecho -b Usage: /KEY <key>
		return
	}

	//mode $C +k $key
}

alias k kick

alias kick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /KICK <nick> [reason]
		return
	}

	//kick $C $nick $reason
}

alias kb kickban

alias kickban (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /KICKBAN <nick> [reason]
		return
	}

	if (onchannel($nick $C)) {
		//kick $C $nick $reason
	}
	ban $nick
}

/*
 * /LEAVE taken from 2.8script, distributed with EPIC.
 */
alias part leave
alias l leave
alias leave
{
	switch ($0)
	{
		(*,*)
		{
			leave $before(, $0) $1-
			leave $after(, $0) $1-
		}
		(#*) (&*) (0) (-*) (!*) (+*)
			{ //leave $* }
		() (\\*)
			{ //leave * $1- }
		(*)
			{ //leave #$* }
	}
}

/* 
 * Your standard /LK. Kicks everyone but +o and +v users
 * out of the current channel.
 */
alias lk (reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!ischanop($N $C))
	{
		xecho -b Sorry, you must be +o to kick people
		return
	}

	^local ask $"Kick all non-ops from $C? "

	if (left(1 $ask) == [y])
	{
		for user in ($channel())
		{
			@ :nick = mid(2 $strlen($user) $user)
			if (match(.. $left(2 $user))) {
				//kick $C $nick $reason
			} else if (match(.? $left(2 $user))) {
				//kick $C $nick $reason
			}
		}
	}
}

alias massmode (chan, action, mode, args)
{
	if (!args)
	{
		xecho -b Usage: /MASSMODE <channel> <+|-> <mode> <mode parameters>
		return
	}

	if (!ischanop($servernick() $chan))
	{
		xecho -b Sorry, you must be +o to set channel modes
		return
	}

	^local tmp
	for cnt from 1 to $CONFIG.MAX_MODES {
		push tmp mode.$cnt
	}
	fe ($args) $tmp
	{
		^local nicks
		for (@:cnt = 1, mode[$cnt], @:cnt++) {
			eval push nicks \$mode[$cnt]
		}
		//mode $chan $action$repeat($#nicks $mode) $nicks
	}
}

alias mdop mdeop

alias mdeop (chan default "$C", void)
{
	if (chops($chan)) {
		massmode $chan - o $remw($servernick() $chops($chan))
	} else {
		xecho -b No channel operators found on $chan
	}
}

alias mdvoice mdevoice

alias mdevoice (chan default "$C", void)
{
	massmode $chan - v $remw($servernick() $onchannel($chan))
}

alias mme
{
	if (match($0 -a -all))
	{
		@ :all_servers = 1
		@ :text = [$1-]
	}{
		@ :text = [$*]
	}

	if (!text)
	{
		xecho -b Usage: /MME [-all] <text>
		return
	}

	if (all_servers)
	{
		for sref in ($serverrefs())
		{
			for chan in ($mychannels($sref)) {
				xeval -s $sref {describe $chan $text}
			}
		}
	}{
		for chan in ($mychannels()) {
			describe $chan $text
		}
	}
}

alias mop (chan default "$C", void)
{
	if (nochops($chan)) {
		massmode $chan + o $remw($servernick() $nochops($chan))
	} else {
		xecho -b No normal users found on $chan
	}
}

alias msay
{
	if (match($0 -a -all))
	{
		@ :all_servers = 1
		@ :text = [$1-]
	}{
		@ :text = [$*]
	}

	if (!text)
	{
		xecho -b Usage: /MSAY [-all] <text>
		return
	}

	if (all_servers)
	{
		for sref in ($serverrefs())
		{
			for chan in ($mychannels($sref)) {
				xeval -s $sref {msg $chan $text}
			}
		}
	}{
		for chan in ($mychannels()) {
			msg $chan $text
		}
	}
}

alias mvoice (chan default "$C", void)
{
	massmode $chan + v $remw($servernick() $onchannel($chan))
}

alias op (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /OP <nick> ...
		return
	}

	massmode $C + o $nicks
}

alias partall (void)
{
	input "Are you sure you want to part all your channels? "
	{
		if (left(1 $0) == [y])
		{
			for chan in ($mychannels()) {
				//part $chan
			}
		}
	}
}

alias settopic (chan default "$C", void)
{
	@ :serv = winserv($winchan($chan))
	@ :array = [channel.topics.$serv\.$chan]

	if (serv == -1)
	{
		xecho -b No server for this window
		return
	}

	topics $chan

	^local prompt $"Change topic on $chan? (Enter a # or 'n' for new): "

	if (prompt == [n])
	{
		^local newtopic $"Enter new topic: "
		//topic $chan $newtopic
	}\
	else if (!isnumber($prompt b10))
	{
		xecho -b You must enter an integer or 'n' to set a new topic
	}\
	else if (prompt > 0 && prompt <= numitems($array))
	{
		@ :item = word(${prompt-1} $jot(${numitems($array)-1} 0))
		//topic $chan $getitem($array $item)
	}\
	else if (!numitems($array))
	{
		xecho -b No topics stored for $chan
	}{
		xecho -b Number out of range
	}
}

alias t topic

/*
 * This imitates the /TBAN command in BitchX. It provides an interactive
 * way to remove bans. I have no idea why this is named what it is and
 * perhaps it should be renamed so that it is not confused with /TEMPBAN.
 */
alias tban (chan default "$C", void)
{
	@ delarray(channel.tban)

	^on #^367 424 "% $chan *"
	{
		@ setitem(channel.tban $numitems(channel.tban) $*)
	}

	^on #^368 424 "% % $chan"
	{
		^local bans
		^local chan $2
		^local tmp $"Which ban(s) to remove? (1, 2-5, ...) "

		for bannum in ($tmp)
		{
			@ :start = before(- $bannum)
 			@ :end = after(- $bannum)
			if (start < end && start < numitems(channel.tban) && end <= numitems(channel.tban))
			{
				for cnt from $start to $end {
					push bans $word(2 $getitem(channel.tban ${cnt - 1}))
				}
			}\
			else if (bannum <= numitems(channel.tban))
			{
				push bans $word(2 $getitem(channel.tban ${bannum - 1}))
			}
		}

		@ :tmp = []
		for cnt from 1 to $CONFIG.MAX_MODES {
			push tmp mode.$cnt
		}
		fe ($bans) $tmp
		{
			^local masks
			for (@:cnt = 1, mode[$cnt], @:cnt++) {
				eval push masks \$mode[$cnt]
			}
			//mode $chan -$repeat($#masks b) $masks
		}

		^on #^367 424 -"% $chan *"
		^on #^368 424 -"% % $chan"
	}
	//mode $chan +b
}

alias tempban (time, target, void)
{
	if (!target || !isnumber($time b10) || time < 1)
	{
		xecho -b Usage: /TEMPBAN <seconds> <nick|mask>
		return
	}

	@ :banmask = ban($target)
	timer $time //mode $C -b $banmask
}

alias tempbk (time, nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /TEMPBK <seconds> <nick> [reason]
		return
	}

	tempban $time $nick
	if (onchannel($nick $C)) {
		//kick $C $nick $reason
	}
}

alias tempkb (time, nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick)
	{
		xecho -b Usage: /TEMPKB <seconds> <nick> [reason]
		return
	}

	if (onchannel($nick $C)) {
		//kick $C $nick $reason
	}
	tempban $time $nick
}

alias topics (chan default "$C", void)
{
	@ :serv = winserv($winchan($chan))
	@ :array = [channel.topics.$serv\.$chan]

	if (serv == -1) {
		xecho -b No server for this window
		return
	}

	if (numitems($array))
	{
		xecho -b Stored topics for $chan (most recent first):
		@ :num = 1
		for ii in ($jot(${numitems($array)-1} 0))
		{
			@ :topic = getitem($array $ii)
			echo $[3]num $topic
			@ :num++
		}
	}{
		xecho -b No topics stored for $chan
	}
}

alias tt etopic

alias ttopic etopic

alias unban (bans)
{
	if (!bans)
	{
		xecho -b Usage: /UNBAN <ban> ...
		return
	}

	massmode $C - b $bans
}

alias unkey (void)
{
	if (match(*k* $chanmode())) {
		//mode $C -k
	} else {
		xecho -b No key on channel $C
	}
}

alias untopic (chan default "$C", void)
{
	//topic -$chan
}

alias voice (nicks)
{
	if (!nicks)
	{
		xecho -b Usage: /VOICE <nick> ...
		return
	}

	massmode $C + v $nicks
}

/*
 * Sends a notice to all +o nicks in the current channel using
 * one of three methods. The method used is determined by the
 * value of the CHANNEL_WALL_TYPE config variable.
 *
 * The possible types are:
 *
 *  1 - Send a single NOTICE to @<channel>
 *  2 - Send NOTICEs to all +o users, seven at a time
 *  3 - Send NOTICEs to all +o users, one at a time (USE WITH CARE)
 */
alias wall (text)
{
	if (!text)
	{
		xecho -b Usage: /WALL <text>
		return
	}

	@ :chan = winchan($winnum())

	switch ($CONFIG.CHANNEL_WALL_TYPE)
	{
		(1)
		{
			notice @$chan [wall/$chan] $text
		}

		(2)
		{
			fe ($filter($servernick() $chops())) o1 o2 o3 o4 o5 o6 o7 {
				notice $o1,$o2,$o3,$o4,$o5,$o6,$o7 [wall/$chan] $text
			}
		}

		(3)
		{
			/* This is evil and should never be used on large channels. */
			for nick in ($filter($servernick() $chops())) {
				notice $nick [wall/$chan] $text
			}
		}

		(*)
		{
			xecho -b /WALL: Error sending message: Invalid CHANNEL_WALL_TYPE
			return
		}
	}

	echo $fparse(SEND_WALL $chan $text)
}


/****** INTERNAL ALIASES ******/

/*
 * Maintains the arrays containing channel topics. This is called by
 * the 332 and TOPIC hooks.
 *
 * The arrays will be named channel.topics.<server>.<channel> and
 * only as many topics as the value of REMEMBER_TOPICS will be kept.
 */
alias channel.topic (serv, chan, topic)
{
	@ :array = [channel.topics.$serv\.$chan]
	@ :head = numitems($array) - 1
	if ((:item = matchitem($array $topic)) > -1) {
		@ delitem($array $item)
	}
	while (numitems($array) >= CONFIG.REMEMBER_TOPICS) {
		@ delitem($array 0)
	}
	@ setitem($array $numitems($array) $topic)
}


/****** ON HOOKS ******/

on ^329 "*"
{
	if (FORMAT.CHANNEL_TS) {
		echo $fparse(CHANNEL_TS $*)
	}
}

on ^332 "*"
{
	channel.topic $servernum($0) $1-
	if (FORMAT.TOPIC) {
		echo $fparse(TOPIC $*)
	}
}

on ^333 "*"
{
	if (FORMAT.TOPIC_SETBY) {
		echo $fparse(TOPIC_SETBY $*)
	}
}

/*
 * Ban list stuff: 367, 368, 369
 */
on ^367 "*"
{
	@ setitem(channel.banlist.$1 $numitems(channel.banlist.$1) $*)
}

on ^368 "*"
{
	for var in (BANS_HEADER BANS_HEADER1 BANS_HEADER2)
	{
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}

	if ([$1] > 0)
	{
		if (FORMAT.BANS)
		{
			@ :endcnt = numitems(channel.banlist.$2) - 1
			for cnt from 0 to $endcnt {
				echo $fparse(BANS ${cnt + 1} $getitem(channel.banlist.$2 $cnt))
			}
		}
		@ delarray(channel.banlist.$2)
	}

	for var in (BANS_FOOTER BANS_FOOTER1 BANS_FOOTER2)
	{
		if (FORMAT[$var]) {
			echo $fparse($var $*)
		}
	}
}

on ^369 "*" #

on ^action "*"
{
	if (iscurchan($1))
	{
		if (FORMAT.ACTION_CHANNEL) {
			echo $fparse(ACTION_CHANNEL $*)
		}
	}{
		if (FORMAT.ACTION_CHANNEL_OTHER) {
			echo $fparse(ACTION_CHANNEL_OTHER $*)
		}
	}
}

on ?channel_nick "*"
{
	if (FORMAT.CHANNEL_NICK)
	{
		echo $fparse(CHANNEL_NICK $*)
		return 1
	}{
		/* Allow client to hook the NICKNAME event. */
		return 0
	}
}

on ?channel_signoff "*"
{
	if (FORMAT.CHANNEL_SIGNOFF)
	{
		echo $fparse(CHANNEL_SIGNOFF $*)
		return 1
	}{
		/* Allow client to hook the SIGNOFF event. */
		return 0
	}
}

on ^channel_sync "*"
{
	if (FORMAT.CHANNEL_SYNC) {
		echo $fparse(CHANNEL_SYNC $*)
	}
}

on ^invite "*"
{
	if (FORMAT.INVITE) {
		echo $fparse(INVITE $*)
	}
}

on ^join "*"
{
	if (FORMAT.JOIN) {
		echo $fparse(JOIN $*)
	}
}

on ^kick "*"
{
	if (FORMAT.KICK) {
		echo $fparse(KICK $*)
	}
}

on ^leave "*"
{
	if (FORMAT.LEAVE) {
		echo $fparse(LEAVE $*)
	}
}

on ^mode "*"
{
	if (FORMAT.MODE) {
		echo $fparse(MODE $*)
	}
}

on ^public "*"
{
	if (CONFIG.AUTO_RESPONSE)
	{
		if (match(*$servernick()* $2-))
		{
			@ :autoresp = 1
		}{
			for word in ($CONFIG.AUTO_RESPONSE_STR)
			{
				if (match(*$word* $2-))
				{
					@ :autoresp = 1
					break
				}
			}
		}

		if (autoresp)
		{
			if (FORMAT.PUBLIC_AR) {
				echo $fparse(PUBLIC_AR $*)
			}
			if (CONFIG.AUTO_RESPONSE_BEEP)
			{
				^stack push set BEEP
				^set BEEP ON
				beep
				^stack pop set BEEP
			}
			if (CONFIG.AUTO_RESPONSE_NOTIFY && winchan($1) != winnum()) {
				xecho -b -c Auto-response triggered in window #$winchan($1) by $0 \($1\)
			}
		}
	}

	if (FORMAT.PUBLIC && !autoresp) {
		echo $fparse(PUBLIC $*)
	}
}

on ^public_other "*"
{
	if (CONFIG.AUTO_RESPONSE)
	{
		if (match(*$servernick()* $2-))
		{
			@ :autoresp = 1
		}{
			for word in ($CONFIG.AUTO_RESPONSE_STR)
			{
				if (match(*$word* $2-))
				{
					@ :autoresp = 1
					break
				}
			}
		}

		if (autoresp)
		{
			if (FORMAT.PUBLIC_OTHER_AR) {
				echo $fparse(PUBLIC_OTHER_AR $*)
			}
			if (CONFIG.AUTO_RESPONSE_BEEP)
			{
				^stack push set BEEP
				^set BEEP ON
				beep
				^stack pop set BEEP
			}
			if (CONFIG.AUTO_RESPONSE_NOTIFY && winchan($1) != winnum()) {
				xecho -b -c Auto-response triggered in window #$winchan($1) by $0 \($1\)
			}
		}
	}

	if (FORMAT.PUBLIC_OTHER && !autoresp) {
		echo $fparse(PUBLIC_OTHER $*)
	}
}

on ^send_action '\\[#% &% +% !%\\] *'
{
	if (iscurchan($0))
	{
		if (FORMAT.SEND_ACTION_CHANNEL) {
			echo $fparse(SEND_ACTION_CHANNEL $servernick() $*)
		}
	}{
		if (FORMAT.SEND_ACTION_CHANNEL_OTHER) {
			echo $fparse(SEND_ACTION_CHANNEL_OTHER $servernick() $*)
		}
	}
}

on ^send_public "*"
{
	if (iscurchan($0))
	{
		if (FORMAT.SEND_PUBLIC) {
			echo $fparse(SEND_PUBLIC $0 $servernick() $1-)
		}
	}{
		if (FORMAT.SEND_PUBLIC_OTHER) {
			echo $fparse(SEND_PUBLIC_OTHER $servernick() $*)
		}
	}
}

on ^topic "*"
{
	channel.topic $servernum() $1-

	if (![$2])
	{
		if (FORMAT.TOPIC_UNSET) {
			echo $fparse(TOPIC_UNSET $*)
		}
	}{
		if (FORMAT.TOPIC_CHANGE) {
			echo $fparse(TOPIC_CHANGE $*)
		}
	}
}

/*
 * Restrict the value of the CHANNEL_WALL_TYPE config variable.
 * Allowed values: 1, 2, 3
 */
on #-hook 428 "CONFIG CHANNEL_WALL_TYPE *"
{
	if (!match($CONFIG.CHANNEL_WALL_TYPE 1 2 3))
	{
		xecho -b Valid types are 1, 2, and 3
		^assign CONFIG.CHANNEL_WALL_TYPE $2
		xecho -b Value of $1 set to $CONFIG.CHANNEL_WALL_TYPE
	}
}

/*
 * Restrict the value of the REMEMBER_TOPICS config variable to an integer
 * that is greater than or equal to zero.
 */
on #-hook 428 "CONFIG REMEMBER_TOPICS *"
{
	if (!isnumber($CONFIG.REMEMBER_TOPICS b10) || CONFIG.REMEMBER_TOPICS < 0)
	{
		xecho -b Value must be an integer greater than or equal to zero
		if (CONFIG.REMEMBER_TOPICS == []) {
			^assign CONFIG.REMEMBER_TOPICS 0
		} else {
			^assign CONFIG.REMEMBER_TOPICS $2
		}
		xecho -b Value of $1 set to $CONFIG.REMEMBER_TOPICS
	}

	/*
	 * Make sure that the size of all the channel topic arrays is no
	 * greater than the new value of REMEMBER_TOPICS.
	 */
	for array in ($getarrays(channel.topics.*))
	{
		while (numitems($array) > CONFIG.REMEMBER_TOPICS) {
			@ delitem($array 0)
		}
	}
}


/* EOF */