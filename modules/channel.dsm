#version 0.5.4
/* $Id$ */
/*
 * channel.dsm - Channel related module for DarkStar/EPIC4
 *
 * Written by Brian Weiss (except where noted)
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial numbers 0 and 424 for /on hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.channel
{
	for alias in (alldeop alldop allop ban bankick banlist bans bk cmode cycle deop dop devoice dvoice i invite j join k kb key kick kickban l leave lk massmode mdeop mdop mdevoice mdvoice mme mop msay mvoice oldtopic op part partall setoldtopic t tban tempban unban unkey untopic voice wall wall2) {
		^alias -$alias
	}
	for hook in (332 333 367 368 369 action channel_nick channel_signoff channel_sync invite join kick leave mode public public_other send_public topic) {
		^on $hook -"*"
	}
	^on public -'% % *\\\\\[\$CONFIG.AUTO_RESPONSE_STR\\\\\]*'
	^on public_other -'% % *\\\\\[\$CONFIG.AUTO_RESPONSE_STR\\\\\]*'
	^on send_action -'\\\\\[#* &* +*\\\\\] *'
}


/****** CONFIG/FORMAT VARIABLES ******/

config.add -b AUTO_RESPONSE 0
config.add -b AUTO_RESPONSE_BEEP 0
config.add    AUTO_RESPONSE_STR
config.add    BANTYPE 3
config.add    DEFAULT_KICK_REASON No soup for you!
config.add    MAX_MODES 4

format.add ACTION_CHANNEL * $1 $3-
format.add ACTION_CHANNEL_OTHER * $1/$2 $3-
format.add BANS $[3]1 $[12]5  $strftime($6 %%x@%%X)  $4
format.add BANS_FOOTER $G Total bans on $3: $2
format.add BANS_FOOTER1
format.add BANS_FOOTER2
format.add BANS_HEADER #   SetBy         When               Ban
format.add BANS_HEADER1
format.add BANS_HEADER2
format.add CHANNEL_NICK $G $2 is now known as $3
format.add CHANNEL_SIGNOFF $G SignOff $2: $1 \($3-%n\) [$tolower($Z)]
format.add CHANNEL_SYNC $G Channel $1 synced in $2 seconds
format.add CHANNEL_TS $G Channel $2 created $strftime($3 %%a %%b %%d %%T %%Z %%Y) [$3]
format.add INVITE $G $1 \($3\) invites you to channel $2
format.add JOIN $G $1 \($3\) has joined $2 at $Z
format.add KICK $G ${[$1] == servernick() ? [You have] : [$1 has]} been kicked off channel $3 by $2 \($4-\)
format.add LEAVE $G $1 \($3\) has left $2 at $Z
format.add MODE $G Mode change \"$3-\" on channel $2 by $1
format.add PUBLIC <$1> $3-
format.add PUBLIC_AR <%W$1%n> $3-
format.add PUBLIC_OTHER <$1:$2> $3-
format.add PUBLIC_OTHER_AR <%W$1%n:$2> $3-
format.add SEND_ACTION_CHANNEL * $servernick() $2-
format.add SEND_ACTION_CHANNEL_OTHER * -> $1: $servernick() $2-
format.add SEND_PUBLIC <$2> $3-
format.add SEND_PUBLIC_OTHER <$1:$2> $3-
format.add TOPIC $G Topic for $2: $3-
format.add TOPIC_CHANGE $G $1 has changed the topic on channel $2 to $3-
format.add TOPIC_SETBY $G The topic was set by $3 on $strftime($4 %%a %%b %%d %%T %%Z %%Y)
format.add TOPIC_UNSET $G $1 has unset the topic on channel $2


/****** USER ALIASES ******/

alias alldop alldeop
alias alldeop (nicks)
{
	if (!nicks) {
		xecho -b Usage: /alldeop <nick1> [nick2] [nick3] ...
		return
	}

	for chan in ($mychannels()) {
		for nick in ($nicks) {
			if (ischanop($servernick() $chan) && ischanop($nick $chan)) {
				//mode $chan -o $nick
			}
		}
	}
}

alias allop (nicks)
{
	if (!nicks) {
		xecho -b Usage: /allop <nick> ...
		return
	}

	for chan in ($mychannels()) {
		for nick in ($nicks) {
			if (ischanop($servernick() $chan) && onchannel($nick $chan) && !ischanop($nick $chan)) {
				//mode $chan +o $nick
			}
		}
	}
}

alias ban (targets)
{
	^local bans,mode

	if (!targets) {
		xecho -b Usage: /ban <nick|hostmask> ...
		return
	}

	for target in ($targets) {
		if (onchannel($target $C)) {
			push bans $mask($CONFIG.BANTYPE $userhost($target))
		} else {
			push bans $target
		}
	}

	massmode $C + b $bans
}

alias bk bankick
alias bankick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick) {
		xecho -b Usage: /bankick <nick> [reason]
		return
	}

	ban $nick
	//kick $C $nick $reason
}

alias bans banlist
alias banlist (chan default "$C", void)
{
	//mode $chan +b
}

alias cmode (mode, ...)
{
	if (!mode) {
		xecho -b Usage: /cmode <modes>
		return
	}

	//mode $C $mode $*
}

alias cycle (chan default "$C", void)
{
	@:key = key($chan)
	//part $chan
	wait
	//join $chan $key
}

alias dop deop
alias deop (nicks)
{
	if (!nicks) {
		xecho -b Usage: /deop <nick> ...
		return
	}

	massmode $C - o $nicks
}

alias dvoice devoice
alias devoice (nicks)
{
	if (!nicks) {
		xecho -b Usage: /devoice <nick> ...
		return
	}

	massmode $C - v $nicks
}

alias i invite
alias invite (nick, channel default "$C", void)
{
	if (!nick) {
		xecho -b Usage: /invite <nick> [channel]
		return
	}

	//invite $nick $channel
}

/*
 * /JOIN taken from 2.8script, distributed with EPIC.
 */
alias j join
alias join
{
	switch ($*)
	{
		(*,*)
		{
			join $before(, $0) $1-
			join $after(, $0) $1-
		}
		(#*) (&*) (0) (-*) (!*) (+*)
			{ //join $* }
		()
			{ //join -i }
		(*)
			{ //join #$* }
	}
}

alias key (key, void)
{
	if (!key) {
		xecho -b Usage: /key <key>
		return
	}

	//mode $C +k $key
}

alias k kick
alias kick (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick) {
		xecho -b Usage: /kick <nick> [reason]
		return
	}

	//kick $C $nick $reason
}

alias kb kickban
alias kickban (nick, reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!nick) {
		xecho -b Usage: /kickban <nick> [reason]
		return
	}

	//kick $C $nick $reason
	ban $nick
}

/*
 * /LEAVE taken from 2.8script, distributed with EPIC.
 */
alias part leave
alias l leave
alias leave
{
	switch ($0)
	{
		(*,*)
		{
			leave $before(, $0) $1-
			leave $after(, $0) $1-
		}
		(#*) (&*) (0) (-*) (!*) (+*)
			{ //leave $* }
		() (\*)
			{ //leave * $1- }
		(*)
			{ //leave #$* }
	}
}

/* 
 * Your standard /LK. Kicks everyone but +o and +v people out of the current
 * channel.
 */
alias lk (reason default "$CONFIG.DEFAULT_KICK_REASON")
{
	if (!ischanop($N $C)) {
		xecho -b Sorry, you gotta be +o to kick people
		return
	}

	^local ask $"Kick all non-ops from $C? "

	if (toupper($left(1 $ask)) == [Y]) {
		for user in ($channel()) {
			@:nick = mid(2 $strlen($user) $user)
			if (match(.. $left(2 $user))) {
				//kick $C $nick $reason
			} else if (match(.? $left(2 $user))) {
				//kick $C $nick $reason
			}
		}
	}
}

alias massmode (chan, action, mode, ...)
{
	if (!chan || !action || !mode || ![$*]) {
		xecho -b Usage: /massmode <channel> <+|-> <mode> <mode parameters>
		return
	}

	^local tmp
	for cnt from 1 to $CONFIG.MAX_MODES {
		push tmp mode.$cnt
	}

	fe ($*) $tmp
	{
		^local nicks
		for (@:cnt = 1, mode[$cnt], @:cnt++) {
			eval push nicks \$mode[$cnt]
		}
		//mode $chan $action$repeat($#nicks $mode) $nicks
	}
}

alias mdop mdeop
alias mdeop (chan default "$C", void)
{
	massmode $chan - o $remw($servernick() $chops($chan))
}

alias mdvoice mdevoice
alias mdevoice (chan default "$C", void)
{
	massmode $chan - v $remw($servernick() $onchannel($chan))
}

alias mme
{
	if (pattern($0* -all)) {
		@:all_servers = 1
		@:text = [$1-]
	} else {
		@:text = [$*]
	}

	if (!text) {
		xecho -b Usage: /mme [-all] <text>
		return
	}

	if (all_servers) {
		for sref in ($serverrefs()) {
			for chan in ($mychannels($sref)) {
				xeval -s $sref describe \$chan \$text
			}
		}
	} else {
		for chan in ($mychannels()) {
			describe $chan $text
		}
	}
}

alias mop (chan default "$C", void)
{
	massmode $chan + o $remw($servernick() $nochops($chan))
}

alias msay
{
	if (pattern($0* -all)) {
		@:all_servers = 1
		@:text = [$1-]
	} else {
		@:text = [$*]
	}

	if (!text) {
		xecho -b Usage: /msay [-all] <text>
		return
	}

	if (all_servers) {
		for sref in ($serverrefs()) {
			for chan in ($mychannels($sref)) {
				xeval -s $sref msg \$chan \$text
			}
		}
	} else {
		for chan in ($mychannels()) {
			msg $chan $text
		}
	}
}

alias mvoice (chan default "$C", void)
{
	massmode $chan + v $remw($servernick() $onchannel($chan))
}

alias oldtopic (chan default "$C", void)
{
	@:oldtopic = gettmatch(channel.oldtopics $chan*)
	if (oldtopic) {
		xecho -b Last topic for $chan: $restw(1 $oldtopic)
	} else {
		xecho -b There is no old topic for $chan
	}
}
			
alias op (nicks)
{
	if (!nicks) {
		xecho -b Usage: /op <nick> ...
		return
	}

	massmode $C + o $nicks
}

alias partall (void)
{
	input "Are you sure you want to part all your channels? "
	{
		if (toupper($left(1 $0)) == [Y]) {
			for chan in ($mychannels()) {
				//part $chan
			}
		}
	}
}

alias setoldtopic (chan default "$C", void)
{
	@:oldtopic = gettmatch(channel.oldtopics $chan*)
	if (oldtopic) {
		//topic $oldtopic
	} else {
		xecho -b There is no old topic for $chan
	}
}

alias t topic

alias tban (chan default "$C", void)
{
	@ delarray(channel.tban)

	^on #^367 424 "% $chan *" {
		@ setitem(channel.tban $numitems(channel.tban) $*)
	}

	^on #^368 424 "% % $chan"
	{
		^local bans
		^local chan $2
		^local tmp $"Which ban(s) to remove? (1, 2-5, ...) "

		for bannum in ($tmp) {
			@:startban = before(- $bannum)
			@:endban = after(- $bannum)
			if (startban < endban && startban < numitems(channel.tban) && endban <= numitems(channel.tban)) {
				for cnt from $startban to $endban {
					push bans $word(2 $getitem(channel.tban ${cnt - 1}))
				}
			} else if (bannum <= numitems(channel.tban)) {
				push bans $word(2 $getitem(channel.tban ${bannum - 1}))
			}
		}

		^local tmp
		for cnt from 1 to $CONFIG.MAX_MODES {
			push tmp mode.$cnt
		}

		fe ($bans) $tmp
		{
			^local masks
			for (@:cnt = 1, mode[$cnt], @:cnt++) {
				eval push masks \$mode[$cnt]
			}
			//mode $chan -$repeat($#masks b) $masks
		}

		^on #^367 424 -"% $chan *"
		^on #^368 424 -"% % $chan"
	}

	//mode $chan +b
}

alias tempban (time, target, void)
{
	if (!time || !target) {
		xecho -b Usage: /tempban <seconds> <nick|mask>
		return
	}

	if (onchannel($target $C)) {
		//mode $C +b $mask($CONFIG.BANTYPE $userhost($target))
		timer $time //mode $C -b $mask($CONFIG.BANTYPE $userhost($target))
	} else {
		//mode $C +b $target
		timer $time //mode $C -b $target
	}
}

alias unban (bans)
{
	if (!bans) {
		xecho -b Usage: /unban <ban> ...
		return
	}

	massmode $C - b $bans
}

alias unkey (void)
{
	if (match(*k* $chanmode())) {
		//mode $C -k
	} else {
		xecho -b No key on channel $C
	}
}

alias untopic (chan default "$C", void)
{
	//topic -$chan
}

alias voice (nicks)
{
	if (!nicks) {
		xecho -b Usage: /voice <nick> ...
		return
	}

	massmode $C + v $nicks
}

/*
 * Sends a notice to all +o nicks in the current channel,
 * seven at a time.
 */
alias wall (text)
{
	if (!text) {
		xecho -b Usage: /wall <text>
		return
	}

	fe ($filter($N $chops())) o1 o2 o3 o4 o5 o6 o7 {
		^notice $o1,$o2,$o3,$o4,$o5,$o6,$o7 [wall/$C] $text
	}
	xecho -l walls -- * > [wall/$C] $text
}

/*
 * This is the same as /wall but only sends one nick per command
 * sent to the server.
 */
alias wall2 (text)
{
	if (!text) {
		xecho -b Usage: /wall2 <text>
		return
	}

	for nick in ($filter($N $chops())) {
		^notice $nick [wall/$C] $text
	}
	xecho -l walls -- * > [wall/$C] $text
}


/****** ON HOOKS ******/

on ^329 "*"
{
	if (FORMAT.CHANNEL_TS) {
		echo $fparse(CHANNEL_TS $*)
	}
}

on ^332 "*"
{
	if (FORMAT.TOPIC) {
		echo $fparse(TOPIC $*)
	}
	if (!getmatches(channel.topics $1*)) {
		@ setitem(channel.topics $numitems(channel.topics) $1-)
	}
}

on ^333 "*"
{
	if (FORMAT.TOPIC_SETBY) {
		echo $fparse(TOPIC_SETBY $*)
	}
}

/*
 * Ban list stuff (367 368 369)
 */
on ^367 "*"
{
	@ setitem(channel.banlist.$1 $numitems(channel.banlist.$1) $*)
}

on ^368 "*"
{
	if ([$1] > 0)
	{
		for var in (BANS_HEADER BANS_HEADER1 BANS_HEADER2) {
			if (FORMAT[$var]) {
				echo $fparse($var $*)
			}
		}

		if (FORMAT.BANS) {
			@:endcnt = numitems(channel.banlist.$2) - 1
			for cnt from 0 to $endcnt {
				echo $fparse(BANS ${cnt + 1} $getitem(channel.banlist.$2 $cnt))
			}
		}

		for var in (BANS_FOOTER BANS_FOOTER1 BANS_FOOTER2) {
			if (FORMAT[$var]) {
				echo $fparse($var $*)
			}
		}

		@ delarray(channel.banlist.$2)
	}{
		xecho -b There are no bans on $2
	}
}

on ^369 "*" #

on ^action "*"
{
	if (iscurchan($1)) {
		if (FORMAT.ACTION_CHANNEL) {
			echo $fparse(ACTION_CHANNEL $*)
		}
	} else {
		if (FORMAT.ACTION_CHANNEL_OTHER) {
			echo $fparse(ACTION_CHANNEL_OTHER $*)
		}
	}
}

on ?channel_nick "*"
{
	if (FORMAT.CHANNEL_NICK) {
		echo $fparse(CHANNEL_NICK $*)
		return 1
	} else {
		return 0
	}
}

on ^channel_signoff "*"
{
	if (FORMAT.CHANNEL_SIGNOFF) {
		echo $fparse(CHANNEL_SIGNOFF $*)
	}
}

on ^channel_sync "*"
{
	if (FORMAT.CHANNEL_SYNC) {
		echo $fparse(CHANNEL_SYNC $*)
	}
}

on ^invite "*"
{
	if (FORMAT.INVITE) {
		echo $fparse(INVITE $*)
	}
}

on ^join "*"
{
	if (FORMAT.JOIN) {
		echo $fparse(JOIN $*)
	}
}

on ^kick "*"
{
	if (FORMAT.KICK) {
		echo $fparse(KICK $*)
	}
}

on ^leave "*"
{
	if (FORMAT.LEAVE) {
		echo $fparse(LEAVE $*)
	}
}

on ^mode "*"
{
	if (FORMAT.MODE) {
		echo $fparse(MODE $*)
	}
}

on ^public "*"
{
	if (FORMAT.PUBLIC) {
		echo $fparse(PUBLIC $*)
	}
}

on ^public_other "*"
{
	if (FORMAT.PUBLIC_OTHER) {
		echo $fparse(PUBLIC_OTHER $*)
	}
}

/*
 * Auto-response
 */
on ^public '% % *\\[$CONFIG.AUTO_RESPONSE_STR\\]*'
{
	if (CONFIG.AUTO_RESPONSE)
	{
		if (FORMAT.PUBLIC_AR) {
			echo $fparse(PUBLIC_AR $*)
		}

		if (CONFIG.AUTO_RESPONSE_BEEP) {
			^stack push set BEEP
			^set BEEP ON
			beep
			^stack pop set BEEP
		}
	}{
		if (FORMAT.PUBLIC) {
			echo $fparse(PUBLIC $*)
		}
	}
}

on ^public_other '% % *\\[$CONFIG.AUTO_RESPONSE_STR\\]*'
{
	if (CONFIG.AUTO_RESPONSE)
	{
		if (FORMAT.PUBLIC_OTHER_AR) {
			echo $fparse(PUBLIC_OTHER_AR $*)
		}

		if (CONFIG.AUTO_RESPONSE_BEEP) {
			^stack push set BEEP
			^set BEEP ON
			beep
			^stack pop set BEEP
		}
	}{
		if (FORMAT.PUBLIC_OTHER) {
			echo $fparse(PUBLIC_OTHER $*)
		}
	}
}

on ^send_action '\\[#* &* +*\\] *'
{
	if (iscurchan($0)) {
		if (FORMAT.SEND_ACTION_CHANNEL) {
			echo $fparse(SEND_ACTION_CHANNEL $*)
		}
	} else {
		if (FORMAT.SEND_ACTION_CHANNEL_OTHER) {
			echo $fparse(SEND_ACTION_CHANNEL_OTHER $*)
		}
	}
}

on ^send_public "*"
{
	if ([$0] == C) {
		if (FORMAT.SEND_PUBLIC) {
			echo $fparse(SEND_PUBLIC $0 $servernick() $1-)
		}
	} else {
		if (FORMAT.SEND_PUBLIC_OTHER) {
			echo $fparse(SEND_PUBLIC_OTHER $servernick() $*)
		}
	}
}

on ^topic "*"
{
	if (![$2]) {
		if (FORMAT.TOPIC_UNSET) {
			echo $fparse(TOPIC_UNSET $*)
		}
	} else {
		if (FORMAT.TOPIC_CHANGE) {
			echo $fparse(TOPIC_CHANGE $*)
		}
	}

	@:topic_itm = matchitem(channel.topics $1*)
	if (topic_itm > -1) {
		@:oldtopic_itm = matchitem(channel.oldtopics $1*)
		if (oldtopic_itm > -1) {
			@ delitem(channel.oldtopics $oldtopic_itm)
		}
		@ setitem(channel.oldtopics $numitems(channel.oldtopics) $getitem(channel.topics $topic_itm))
		@ delitem(channel.topics $topic_itm)
	}

	@ setitem(channel.topics $numitems(channel.topics) $1-)
}


/* EOF */