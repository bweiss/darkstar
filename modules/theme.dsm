#version 0.1
/* $Id$ */
/*
 * theme.dsm - Theme system for DarkStar/EPIC4
 * Copyright (c) 2003 Brian Weiss
 * See the 'COPYRIGHT' file for more information.
 *
 * This script uses serial number 428 for all /ON hooks.
 */

/****** CLEANUP QUEUE ******/

queue cleanup.theme
{
	^alias -theme
	^alias -tabkey.cmd.theme
	^on #hook 428 -"CONFIG THEME *"
	^on #hook 428 -"LOADMOD *"
}


/****** CONFIG/FORMAT VARIABLES ******/

addconfig THEME


/****** USER ALIASES ******/

/*
 * /THEME [new theme]
 * /THEME -save [name]
 *
 * The first form changes the current theme. If [new theme] is not
 * specified the list of available themes will be displayed and the
 * user will be prompted to choose one, either by name or number.
 *
 * The second form will create a new theme named [name] in the user
 * directory. If no name is specified "custom" will be used.
 */
alias theme (...)
{
	if (match($0 -s -save))
	{
		/* not implemented yet */
		theme.save $1
		return
	}

	theme.build_list

	if (![$0])
	{
		theme.list
		^local theme $"Which theme would you like to use? "
		if (!theme) {
			return
		}
	}{
		/* theme.list handles this if there are no arguments */
		theme.build_list
		@ :theme = [$0]
	}

	@ :theme = getitems(theme.names -1 $theme)

	if (theme)
	{
		@ :item = finditem(theme.names $theme)
		@ :tdir = getitem(theme.dirs $item)
		for file in ($glob($tdir\/\*)) {
			if (after(-1 / $before(-1 / $file)) != [CVS]) {
				load $file
			}
		}
		@ CONFIG.THEME = theme
		xecho -b -s Now using theme: $theme
	}{
		xecho -b -s Theme not found: $theme
	}
}


/****** INTERNAL ALIASES ******/

if (isloaded(tabkey))
{
	^alias tabkey.cmd.theme (...)
	{
		@ function_return = tabkey.nofallback($tabkey.method.array(theme.names $*))
	}
}

/*
 * Scans the theme directories and stores available themes in two arrays,
 * one for theme names (themes) and one for theme directories (theme_dirs).
 */
alias theme.build_list (void)
{
	theme.scan_dir $DS.HOME/themes
	theme.scan_dir $DS.USER_DIR/themes
}

alias theme.list (void)
{
	theme.build_list
	xecho -b Current theme: $CONFIG.THEME
	xecho -b Available themes:
	for ii from 1 to $numitems(theme.names) {
		echo $[3]ii $getitem(theme.names ${ii-1})
	}
}

alias theme.save (name, void)
{
	echo theme.save not implemented yet
}

alias theme.scan_dir (dir, void)
{
	if (!dir) {
		echo Error: theme.scan_dir: Not enough arguments
		return
	}

	@ :dir = twiddle($dir)
	for tdir in ($glob($dir\/\*))
	{
		@ :name = after(-1 / $before(-1 / $tdir))
		if (name == [CVS]) {
			continue
		}
		if ((:item = finditem(theme.names $name)) > -1) {
			@ delitem(theme.names $item)
		}
		@ setitem(theme.names $numitems(theme.names) $name)
		@ setitem(theme.dirs $numitems(theme.dirs) $tdir)
	}
}


/****** ON HOOKS ******/

/*
 * Change themes on /DSET THEME and restrict its value to valid theme names.
 */
on #-hook 428 "CONFIG THEME *"
{
	if (CONFIG.THEME && ascii($CONFIG.THEME) != ascii($2))
	{
		if (finditem(theme.names $CONFIG.THEME) < 0)
		{
			xecho -b Invalid theme: $CONFIG.THEME
			^assign CONFIG.THEME $2
			xecho -b Value of THEME set to $2
		}{
			^theme $CONFIG.THEME
		}
	}
}

on #-hook 428 "LOADMOD *"
{
	/*
 	 * Load theme file for this module.
	 */
	if ((:item = finditem(theme.names $CONFIG.THEME)) > -1)
	{
		@ :dir = getitem(theme.dirs $item)
		if (fexist($dir$1) == 1) {
			load $dir$1
		}
	}

	/*
	 * Add completion for /THEME whenever the tabkey module is loaded.
	 */
	if ([$1] == [tabkey])
	{
		^alias tabkey.cmd.theme (...)
		{
			@ function_return = tabkey.nofallback($tabkey.method.array(theme.names $*))
		}
	}
}


/****** STARTUP ******/

defer
{
	if (!CONFIG.THEME)
	{
		theme.build_list
		theme.list

		@ :holdslider = windowctl(GET $winnum() HOLD_SLIDER)
		@ :holdmode   = windowctl(GET $winnum() HOLDING_DISTANCE) > -1 ? [ON] : [OFF]
		^window hold_slider 0
		^window hold_mode on

		input "Which theme would you like to use? "
		{
			if ([$0]) {
				theme $0
			}
		}

		^window hold_slider $holdslider
		^window hold_mode $holdmode
	}{
		theme $CONFIG.THEME
	}
}


/* EOF */