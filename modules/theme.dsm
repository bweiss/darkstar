# version:0.1.4 loader:pf
# $Id$
#
# theme.dsm - Theme system for DarkStar/EPIC5
# Copyright (c) 2003 Brian Weiss
# See the 'COPYRIGHT' file for more information.
#
# This script uses serial number 428 for all /ON hooks.
#

queue cleanup.theme
{
	^alias -tabkey.cmd.theme;
	^on #hook 428 -"CONFIG THEME *";
	^on #hook 428 -"LOADMOD *";
};


addconfig THEME;


#
# /THEME [new theme]
# /THEME -save [name]
#
# The first form changes the current theme. If [new theme] is not
# specified the list of available themes will be displayed and the
# user will be prompted to choose one, either by name or number.
#
# The second form will create a new theme named [name] in the user
# directory. If no name is specified "custom" will be used.
#
alias theme (...)
{
	if (match($0 -s -save))
	{
		theme.save $1;
		return;
	};

	theme.build_list;

	if (![$0])
	{
		theme.list;
		^local theme $"Which theme would you like to use? ";
		if (!theme)
			return;
	}{
		# theme.list calls theme.build_list if there are no arguments.
		theme.build_list;
		@ :theme = [$0];
	};

	if (isnumber(b10 $theme)) {
		@ :item = theme - 1;
		@ :theme = getitem(theme.names $item);
	} else {
		@ :item = finditem(theme.names $theme);
	};

	if (item > -1 && item < numitems(theme.names))
	{
		@ :tdir = getitem(theme.dirs $item);
		for file in ($glob($tdir\/\*)) {
			if (after(-1 / $before(-1 / $file)) != [CVS]) {
				load $file;
			};
		};
		@ CONFIG.THEME = theme;
		xecho -b -c -s Now using theme: $theme;
	}{
		xecho -b -c -s Theme not found: $theme;
	};
};


if (isloaded(tabkey))
{
	^alias tabkey.cmd.theme (...)
	{
		@ function_return = tabkey.nofallback($tabkey.method.array(theme.names $*));
	};
};

alias theme.build_list (void)
{
	theme.scan_dir $DS.HOME/themes;
	theme.scan_dir $DS.USER_DIR/themes;
};

alias theme.list (void)
{
	theme.build_list;
	xecho -b -c Current theme: $CONFIG.THEME;
	xecho -b -c Available themes:;
	for ii from 1 to $numitems(theme.names) {
		echo $[3]ii $getitem(theme.names ${ii-1});
	};
};

alias theme.save (name, void)
{
	@ :name = name ? name : [custom];
	@ :dir  = [$twiddle($DS.USER_DIR)/themes/$name];

	if (fexist($dir) == 1)
	{
		^local ask_overwrite $'A theme by the name "$name" already exists. Overwrite? ';
		if (ask_overwrite == [y]) {
			for file in ($glob($dir/*)) {
				@ unlink($file);
			};
		} else {
			return;
		};
	}{
		@ mkdir($dir);
	};

	for mod in (core $loadedmods())
	{
		if (numitems(_FSET.$mod))
		{
			@ unlink($dir/$mod);
			@ :fd = open($dir/$mod W);

			if (fd != -1)
			{
				@ write($fd # Generated by DarkStar $DS.VERSION \($DS.INTERNAL_VERSION\) [$DS.CORE_ID] - $strftime(%a %b %d %T %Z %Y));
				@ write($fd );

				if (mod == [core])
				{
					@ write($fd dset DOUBLE_STATUS ${CONFIG.DOUBLE_STATUS ? [ON] : [OFF]});
					@ write($fd );
					for setvar in (BANNER INPUT_PROMPT $getsets(STATUS_*))
					{
						# The '$' here is intentional. It forces double expansion.
						@ :value = $setvar;
						if (value != []) {
							@ write($fd set $setvar $value);
						} else {
							@ write($fd set -$setvar);
						};
					};
					@ write($fd );
				}
				else if (mod == [formats])
				{
					if (CONFIG.NAMES_COL != []) {
						@ write($fd assign CONFIG.NAMES_COL $CONFIG.NAMES_COL);
					} else {
						@ write($fd assign -CONFIG.NAMES_COL);
					};
					@ write($fd );
				};

				# This alias is part of save.dsc
				_save.write_format_vars $fd $mod;

				@ close($fd);
			}{
				echo Error: theme.save: Unable to write to file: $dir/$mod;
			};
		};
	};

	xecho -b Theme saved to $dir;
};

#
# Scans a directory for themes and stores information about them in
# two arrays: theme.names and theme.dirs.
#
alias theme.scan_dir (dir, void)
{
	if (!dir) {
		echo Error: theme.scan_dir: Not enough arguments;
		return;
	};

	@ :dir = twiddle($dir);
	for tdir in ($glob($dir\/\*))
	{
		@ :name = after(-1 / $before(-1 / $tdir));
		if (name == [CVS]) {
			continue;
		};
		if ((:item = finditem(theme.names $name)) > -1) {
			@ delitem(theme.names $item);
			@ delitem(theme.dirs $item);
		};
		@ setitem(theme.names $numitems(theme.names) $name);
		@ setitem(theme.dirs $numitems(theme.dirs) $tdir);
	};
};


#
# Change themes on /DSET THEME and restrict its value to valid theme names.
#
on #-hook 428 "CONFIG THEME *"
{
	if (CONFIG.THEME && ascii($CONFIG.THEME) != ascii($2))
	{
		if (finditem(theme.names $CONFIG.THEME) < 0)
		{
			xecho -b Unknown theme: $CONFIG.THEME;
			defer dset THEME $2;
		}{
			^theme $CONFIG.THEME;
		};
	};
};

on #-hook 428 "LOADMOD *"
{
 	# Load theme file for this module.
	if ((:item = finditem(theme.names $CONFIG.THEME)) > -1)
	{
		@ :dir = getitem(theme.dirs $item);
		if (fexist($dir$1) == 1) {
			load $dir$1;
		};
	};

	# Add completion for /THEME whenever the tabkey module is loaded.
	if ([$1] == [tabkey])
	{
		^alias tabkey.cmd.theme (...)
		{
			@ function_return = tabkey.nofallback($tabkey.method.array(theme.names $*));
		};
	};
};


defer
{
	if (!CONFIG.THEME)
	{
		theme.build_list;
		theme.list;

		@ :holdslider = windowctl(GET $winnum() HOLD_SLIDER);
		@ :holdmode   = windowctl(GET $winnum() HOLDING_DISTANCE) > -1 ? [ON] : [OFF];
		^window hold_slider 0;
		^window hold_mode on;

		input "Which theme would you like to use? "
		{
			if ([$0]) {
				theme $0;
			};
		};

		^window hold_slider $holdslider;
		^window hold_mode $holdmode;
	}{
		theme $CONFIG.THEME;
	};
};

