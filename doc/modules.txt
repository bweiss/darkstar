Guide to the DarkStar module loading system.
$Id$

This intends to document the DarkStar module loading system as well as
explain methods for writing high quality modules. It is geared towards
people with some experience in ircII-EPIC scripting that are looking to
write their own modules or are just interested in understanding the
DarkStar core scripts. Note: This script pack is still under heavy
development and I make no guarantees about any of this being consistent
between versions.

What is a DarkStar module? Well, in its simplest form, it's just like any
other script that you might /LOAD, but it contains a special block of code
which I call a "cleanup queue" (using /QUEUE). This cleanup queue is
responsible for removing certain pieces of code when the module is unloaded.
This is due to the fact that the module loader has no way to reliably keep
track of everything the module adds, so certain things must be specified
for removal by the module itself. I hope to remedy this as soon as it
becomes possible to do so. For now, this is something we're stuck with.

Technically, the only thing required to make a script available as a
DarkStar module is to place it in one of the module directories with
a ".dsm" extension. Of course, the module won't unload properly and
could cause all sorts of problems if the user ever tries to do so.
Including a cleanup queue and keeping it up-to-date is pretty important
and I strongly urge all module authors to take the time to do this..

Nothing else needs to be done in order for a script to become a DarkStar
module. However, there are a variety of features provided by the core
scripts that module authors may want to take advantage of. I will go into
detail about some of these, as well as the cleanup queue, in the comments
of the example module below.


--- START OF FILE: sample.dsm ---
#version 0.1.3
# The above line is an optional tag that is read by the module loader
# (/LOAD sees it as a comment). If present, the number proceeding it will
# be stored in the module_version array, and is displayed in the output
# of /MODLIST. It must be the first line of the file or it will not work.
/*
 * sample.dsm - Example module for DarkStar/EPIC4
 *
 * Written by Brian Weiss <brian@epicsol.org>
 * Copyright (c) 2002 Brian Weiss
 * See the 'COPYRIGHT' file for details.
 *
 * Standard header comment, you can put whatever you like here. To make
 * things easy on other module authors, I like to include a line like the
 * one below whenever I have /on hooks. 
 *
 * This script uses serial numbers 0 and 123 for all /on hooks.
 */

/*
 * The most important part, the cleanup queue. This removes anything
 * that the module adds that is not automatically removed by the module
 * loader. This means all /on hooks, all arrays, and any alias or assign
 * not in a structure named after the module (i.e. Anything not obviously
 * associated with that module). It is also important to note that there
 * is one evaluation being performed on the body of this queue, so there
 * are times you will have to escape certain characters like '$'. An example
 * of this is shown here in the /on public hook. The name of this queue
 * must be in the form of "cleanup.<modulename>" and must match the exact
 * module name (if the module is named "foo2", the cleanup queue must be
 * named "cleanup.foo2"). Also note that all /alias, /assign, and /on
 * commands include the silent mode (^) to prevent them from outputting
 * anything when the cleanup queue is executed.
 */
queue cleanup.sample
{
	^alias -foo
	^on public -'% % \$CONFIG.SAMPLE_TRIGGER *'
	^on #hook 123 -"CONFIG SAMPLE_WINDOW *"
	@ delarray(foobar)
}

/*
 * The aliases config.add and format.add (provided by core/config.dsc) add
 * config and format variables whose values can be changed via /DSET and
 * /FSET. The '-b' option passed to config.add creates a boolean variable.
 * Please see the comments in config.dsc for the complete usage of these
 * commands. These variables are removed automatically when the module
 * that added them is unloaded.
 *
 * IMPORTANT! The actual values of these variables will reside in the
 * CONFIG structure and should be accessed (and sometimes directly changed)
 * from there. See examples later in this file.
 */
config.add -b FOO 1
config.add    SAMPLE_TRIGGER !foo
config.add -b SAMPLE_WINDOW 1

/*
 * Format variables should be used with $fparse() and $fparse2() (the only
 * difference is that fparse2 doesn't pass the string through $cparse() for
 * color coding) and are generally used to format the output resulting from
 * certain events. This allows for easy configuration as well as theme
 * support. See the /on public hook for an example. The numeric expandos
 * ($0, $1, $2, etc.) will be expanded to the arguments passed to the
 * fparse functions. Note that the first argument ($0) will be the name of
 * the format variable. See the /on public hook for the call to $fparse()
 * in this example.
 */
format.add BLAH <%G$1%n> $3-

/*
 * Force the loading of saved settings early so we can use them
 * at load time. Example directly below. Also see modules/window.dsm
 * and modules/misc.dsm.
 */
module.load_saved_settings

/*
 * Create a split window named "sample" at load time. This window
 * can also be created or killed whenever $CONFIG.SAMPLE_WINDOW is
 * changed via /DSET by creating an '/on hook' event that catches
 * config changes. See example below the public hook.
 */
if (CONFIG[SAMPLE_WINDOW])
{
	window new name sample hide
}

/*
 * There is no way for the module loader to be sure what this alias belongs
 * to, so it must be removed in the cleanup queue.
 */
alias foo (void)
{
	echo foobar!
}

/*
 * This will automatically be removed by the module loader, as it is
 * in a structure named after the module. It need not be removed in
 * the cleanup queue.
 */
alias sample.speak (target defalt "$C", void)
{
	if (!target)
	{
		return
	}

	msg $target foobar!
}

/*
 * All /ON hooks must be removed in the cleanup queue.
 */
on ^public '% % $CONFIG.SAMPLE_TRIGGER *'
{
	if (FORMAT[BLAH])
	{
		echo $fparse(BLAH $*)
	}

	if (CONFIG[FOO] && finditem(foobar $0) == -1)
	{
		/* All arrays must also be removed from the cleanup queue. */
		@ setitem(foobar $numitems(foobar) $0)
		sample.speak $0
	}
}

/*
 * This hook kills or creates the "sample" window whenever the user
 * changes the value of $CONFIG.SAMPLE_WINDOW with /DSET. Since the
 * new value of the variable is already stored in the CONFIG structure
 * after it is set, the previous value is passed to this hook after the
 * variable name in order to allow the module to reset it to the previous
 * value. See the hook at the bottom of modules/names.dsm for an example
 * of this.
 */
on #-hook 123 "CONFIG SAMPLE_WINDOW *"
{
	if (CONFIG[SAMPLE_WINDOW])
	{
		window new name sample last
	}{
		window sample kill
	}
}



--- END OF FILE: sample.dsm ---


That should give you a pretty good taste of what makes up a module. At this
point you may want to have a closer look at the various modules that are
included in the script pack. Other areas of interest would be commands.dsc
and functions.dsc in the core/ directory. And if you feel brave, have a
peak at config.dsc and loader.dsc ;). Please feel free to email me if you
have a question about something not covered here, or especially if you have
a suggestion for how something can be improved. That's all for now,
happy scripting!

 - Brian Weiss <brian at epicsol.org>


EOF